## 7.1 定义抽象数据类型

定义在类内部的函数是隐式的`inline`函数。定义在类外部的函数是默认的非`inline`函数。

我们通过在成员函数的参数列表后加一个`const`来表示这是一个**常量成员函数（const member function）**。这样定义使得传入到该函数的`this`指针是一个指向常量的指针，这就**禁止了该函数修改调用它的对象的数据成员**。此时函数对数据是只读的。

编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。因此成员函数可以随意使用类中的其他成员而无须在意它们出现的次序。

IO类不能被拷贝，所以将IO类作为参数传递时只能传引用。读取和写入的操作会改变流的内容，所以如果想要使用IO流，就应该使用普通引用，而非常量引用。

执行类的输出任务的函数应该尽量减少对格式的控制。比如不要有多余的换行。

### 7.1.4 构造函数

构造函数在`const`对象的构造过程中可以向其写值。直到构造函数完成初始化过程，对象才真正取得其“常量”属性。

#### 默认构造函数

编译器在某些情况下无法为类生成默认的构造函数。比如一个类中包含另一个类的对象作为成员变量，而该类没有默认构造函数，则编译器无法生成默认构造函数。还有一些情况见13.1.6节。

C++ 11中，如果我们自定义了构造函数，但又想保留原有的默认构造函数，可以使用`[类名]() = default;`的形式。`=default`既可以出现在类的内部，也可以作为定义的一部分出现在类的外部。

#### 构造函数初始值列表

如果构造函数的目的只是为类成员赋初始值的话，可以使用形式简洁的**构造函数初始值列表（constructor initialize list）**。其形式为在形参列表后跟一个冒号`:`，再跟各类成员的名字，其后加括号以赋初值。例子：

```c++
Sales_data(const std::string &s) : bookNo(s) {}
Sales_data(const std::string &s, unsigned n, double p)
    : bookNo(s), units_sold(n), revenue(p * n) {}
```

因为构造函数无需执行额外的操作，所以函数体为空。

### 7.1.5 拷贝、赋值和析构

除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。

如果没有主动定义这些行为，编译器会自动生成一个。但管理动态内存的类通常不能依赖自动生成的版本。此时宜使用`vector`或`string`替代动态内存部分。

## 7.2 访问控制与封装

使用`struct`定义的类，默认访问权限（也是唯一访问权限）是`public`；使用`class`定义的类，默认访问权限是`private`。

### 7.2.1 友元

类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的**友元（friend）**：

```c++
class Sales_data {
    friend Sales_data add(const Sales_data&, const Sales_data&);
    friend std::istream &read(std::istream&, Sales_data&);
    friend std::ostream &write(std::ostream&, Sales_data&);
    public:
    	...
    private:
    	...
}
```

友元声明只能出现在类定义的内部。一般来说，最好在类定义开始或结束的地方集中声明友元。

#### 友元的声明

友元声明仅仅指定了访问权限，除去上面提到的声明外，还需要再专门对函数进行一次声明。我们通常将友元函数本身的声明和类本身放在同一个头文件中。

有些编译器并不强制遵守上面的限制，但仍然建议按照标准编程。

## 7.3 类的其他特性

类允许将另一个类作为它的成员，而且支持类型别名。此时要求另一个类必须预先定义。

#### 内联成员函数

定义在类内部的函数默认是`inline`的，定义在类外部的函数默认是非`inline`的，但定义时可以加上`inline`关键字显式指定。

#### 可变数据成员

在变量声明中加入`mutable`关键字，则这个变量就成为**可变数据成员**。可变数据成员永远不是`const`，即使它是`const`类型的成员。这样，一个`const`成员函数也可以修改这类变量的值。

### 7.3.2 返回`*this`的成员函数

一个`const`成员函数如果以引用的形式返回`*this`，那么它的返回类型将是常量引用。

使用小规模成员函数取代固定代码的好处：

- 避免在多处使用同样的代码。
- 我们预期随着类的规模的发展，函数有可能变得更加复杂。此时使用函数的作用就比较明显了。
- 开发时可以为函数添加一些调试信息，这些信息将在最后的发布版本移除。此时使用函数比较方便。

- 将函数声明为`inline`可以避免运行时开销。

### 7.3.3 类类型

#### 类的声明

允许只是声明一个类而暂时不定义它：

```c++
class Screen;
```

这种声明称为**前向声明（forward declaration）**，声明后定义前的类被称为**不完全类型（incomplete type）**。不完全类型仅能用于：

- 定义指向这种类型的指针或引用
- 声明（不能定义）返回这种类型的函数

一旦类的名字出现后，就被认为是声明过了。

### 7.3.4 友元再探

友元有三种情况：

1. 普通函数（不是任何类的成员）
2. 其他类
3. （已经定义的）其他类的成员函数

如果一个类指定了友元类，则友元类的成员函数可以访问这个类的**所有**成员，无视权限。

友元没有传递性。即某个类的友元的友元不是它的友元。

对于上面的3，在声明友元关系时，必须明确指出函数属于哪个类：

```c++
class Screen {
    friend void Window_mgr::clear(ScreenIndex);
};
```

重载函数被视为不同的函数。因此如果上面的友元声明涉及重载函数，则应逐个声明。

## 7.4 类的作用域

编译器处理完类中的全部声明后才会处理成员函数的定义。因此在类内部使用类的成员时，无需关注成员是否已经出现了。

## 7.5 构造函数再探

在构造函数体中对数据成员赋值的过程**不是**初始化。构造函数体开始执行就标志着类成员的初始化完成了。因此对于（未提供默认构造函数的）类类型成员、`const`成员、引用成员，必须采用构造函数初始值列表进行初始化。

建议尽可能地使用构造函数初始值列表，而不要在函数体内进行赋值。

使用构造函数初始值列表进行初始化时，初始化的顺序与成员在**类定义**中出现的顺序相同，而不受初始值列表中出现顺序的影响。应尽可能使上述两种顺序保持一致，而且最好不要用一个成员初始化另一个成员。例：

```c++
class X {
    int i, j;
public:
    	X(int val) : j(val), i(j) {}	//不好
}

... {
    ...
    X(int val) : i(val), i(val) {}		//好
}
```

### 7.5.2 委托构造函数

C++ 11引入了**委托构造函数（delegating constructor）**。委托构造函数使用它所属的类的其他构造函数执行自己的初始化过程。换句话说，它把自己的一部分（或全部）职责委托给其他构造函数。

```c++
class Sales_data {
public:
    Sales_data(std::string s, unsigned cnt, double price) : bookNo(s), units_sold(cnt), revenue(cnt * price) {}
    Sales_data() : Sales_data("", 0, 0) {}
    Sales_data(std::string s) : Sales_data(s, 0,0 ) {}
    Sales_data(std::istream &is) : Sales_data() {
        read(is, *this);
    }     
};
```

### 7.5.3 默认构造函数的作用

在实际中，如果定义了其他构造函数，那么最好也提供一个默认的构造函数。

声明一个默认构造函数初始化的对象：

```c++
Sales_data obj1();		//错误，这是声明了一个函数
Sales_data obj2;		//正确
```

### 7.5.4 隐式的类类型转换

C++存在一种从构造函数的**单个实参**的类型隐式转换为类类型的机制。这种构造函数称为**转换构造函数（converting constructor）**。

在`Sales_data`类中，已经定义了接受`string`的构造函数和接受`istream`的构造函数，那么在需要使用`Sales_data`的地方，我们可以使用`string`或`istream`作为替代：

```c++
string null_book = "9-999-99999-9";
//构造一个临时的Sales_data对象
//该对象由只接受string的构造函数执行初始化
item.combine(null_book);
```

编译器将用给定的`string`自动创建一个`Sales_data`对象，并将其传递给`combine`。

编译器只会自动地执行一步类型转换，即上面如果直接向`combine`传递`"9-999-99999-9"`，则无法通过编译。

#### 抑制构造函数定义的隐式转换

可以将单参数构造函数声明为`explicit`从而阻止上述转换。

只能在类内的声明处使用`explicit`，在外部定义处不可。

我们仍然可以显式地使用`explicit`构造函数进行强制类型转换：

```c++
item.combine(Sales_data(null_book));
item.combine(static_cast<Sales_data>(cin));
```

标准库中，

- 接受一个单参数的`const char*`的`string`构造函数不是`explicit`的。
- 接受一个容量参数的`vector`构造函数是`explicit`的。

### 7.5.5 聚合类

**聚合类（aggregate class）**是一种特殊的类，允许用户使用一个用大括号括起来的列表初始化对象。聚合类需要满足以下条件：

- 所有成员都是`public`的。
- 没有定义任何构造函数。
- 没有类内初始值。
- 没有基类，也没有虚函数。

显然C中定义的结构体就是一种聚合类。

```c++
struct Data {
    int ival;
    string s;
};
//初始化时，初始值的顺序必须与成员的声明顺序一致。
Data val1 = {0, "Anna"}; 	//正确
Data val2 = {"Anna", 0};	//错误
```

如果列表中的值少于成员个数，则剩下的成员执行值初始化。

## 7.6 类的静态成员

类的静态成员函数不能是`const`的，也不能使用`this`指针。

访问静态成员时，使用`::`运算符。

在类外定义静态成员函数时，无需（也不能）再次使用`static`。

