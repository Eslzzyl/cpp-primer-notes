## 3.1 命名空间的`using`声明

每个名字都需要独立的`using`声明：

```c++
using std::cout;	//正确
using std::endl;

using std::cout, std::endl;	//错误
```

位于头文件的代码一般不宜使用`using`声明。

## 3.2 标准库类型`string`

本节描述`string`的最常见的用法，9.5节还将介绍另外一些。

`string`的几种初始化方式：

```c++
string s1;		//默认初始化，s1是空串
string s2(s1);	//s2是s1的副本
string s2 = s1;	//等价于s2(s1)
string s3("value");	//s3是字面值"value"的副本，自动去掉字面值结尾处的'\0'
string s3 = "value";//等价于s3("value")
string s4(n, 'c');	//把s4初始化为连续n个c字符组成的串（直接初始化）
string s4 = string(n, 'c');	//等价于上面的写法（拷贝初始化），但不推荐这样写 
```

`string`的常见操作：

```c++
os << s;	//将s写入到输出流os中，返回os
is >> s;	//从输入流读入s，从第一个非空格字符开始读取，直到第一个空格。返回is
getline(is, s);	//从is读取一行赋给s，返回is，自动去掉换行符
s.empty();	//s为空返回true，否则返回false
s.size();	//返回s中字符的个数
s[n];		//s中第n个字符的引用，n从0算起
s1 + s2;	//返回s1和s2连接的结果，也支持+=
s1 = s2;	//用s2的副本代替s1中原来的字符
s1 == s2;	//相等性判断。大小写敏感
s1 != s2;
<, >, <=, >=	//利用字符在字典中的顺序比较，大小写敏感
```

`string::size()`返回的类型是`string::size_type`，是一个无符号整型数。可以用`auto`自动推断类型。注意不要将有符号类型（如`int`）与`string::size_type`混用。

`string`的字典比较的规则：

* 如果两个`string`长度不同，且短的每一位都和长的对应位相等，则短的小于长的。
* 如果两个`string`在某些字符位置上不一致，则返回的是第一个相异字符的字典比较结果。

`string`的`+`也可以用来组合字面值和`string`对象，但`+`两端必须有至少一个是`string`对象。

如果想要处理`string`中的单个字符，可以使用头文件`cctype`中的函数。在使用C语言头文件时，应该用`cname`的格式，而不应该用`name.h`。因为在`cname`中定义的名字属于命名空间`std`，但`name.h`不是。这说明`cname`是C++标准库的一部分。

在使用下标访问`string`时，最好使用`string::size_type`类型，而不要用C中习惯使用的`int`。标准库**不检查**下标的合法性，使用时须注意。

### 范围`for`语句

```c++
for (declaration : expression)
	statement
```

如果希望通过`declaration`改变`expresion`中的值，需要把`declaration`定义成引用：

```c++
for (auto &declaration : expression)
    statement
```

范围for语句不应改变`expression`的大小。否则很容易出问题。例如，如果要在循环中向一个`vector`中添加元素，就不要使用范围for。具体原因见5.4.3节。

## 3.3 标准库类型`vector`

### 3.3.1 定义和初始化`vector`对象

C++既有类模板，又有函数模板。模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为**实例化（instantiation）**。

`vector`可以容纳大部分类型，但引用不是类型，所以`vector`不能容纳引用。

`vector`的几种初始化方式：

```c++
vector<T> v1;		//v1是一个空的vector
vector<T> v2(v1);	//v2包含v1中所有元素的副本
vector<T> v2 = v1;	//同上
vector<T> v3(n, val);	//用n个同样的val元素初始化v3
vector<T> v4(n);	//用n个执行了值初始化的对象初始化v4，见下
vector<T> v5{a, b, c, ...};	//v5包含初始值个数的元素，每个元素赋予相应的初始值
vector<T> v5 = {a, b, c, ...};	//同上
```

**值初始化（value-initialized）**的元素的值由元素类型决定。如`int`的默认值是0，类类型的默认值则由类默认初始化。

注意花括号与圆括号的区分：

```c++
vector<int> v1(10);		//v1有10个元素，每个值都是0
vector<int> v2{10};		//v2有一个元素，值为10
vector<int> v3(10, 1);	//v3有10个元素，值都是1
vector<int> v4{10, 1};	//v4有两个元素，值分别为10和1
```

一般地，圆括号用来**构造（construct）**`vector`对象，花括号用来**列表初始化（list initialize）**`vector`对象。使用花括号进行列表初始化时，要求花括号中的值与`vector`定义的类型保持一致。如果初始化时使用了花括号的形式但提供的值不能用于列表初始化（类型不一致），则要考虑用它来构造`vector`。如：

```c++
vector<string> v5{"hi"};	//列表初始化，v5有一个元素，值为"hi"
vector<string> v6("hi");	//错误写法：不能用字符串字面值构造vector<string>
vector<string> v7{10};	//v7有10个默认初始化的元素
vector<string> v8{10, "hi"};	//v8有10个值为"hi"的元素
```

### 3.3.2 向`vector`对象中添加元素

C++标准要求`vector`对象可以高效快速地添加元素。事实上在定义时初始化元素的性能比依次尾插（`push_back()`）性能更差。唯一的例外是所有元素的值都一样。所以，当元素值不同时，应当尽量选择尾插的方法。

### 3.3.3 其他`vector`操作

`vector`用法的详细介绍可参考[这篇菜鸟教程](https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html)。

`vector`的`size()`返回的是`size_type`类型，具体取决于定义`vector`所用的类型。比如一个`vector<int>`对象的`size()`返回的是`vector<int>::size_type`类型。没有`vector::size_type`这种东西。

有关比较和相等性的判断方式与`string`类似。

`vector`和`string`的`[]`运算符只能用于访问已经存在的元素，而不能增加元素。使用`[]`访问一个不存在的元素是很常见的错误，称为**缓冲区溢出（buffer overflow）**。

确保下标合法的有效手段是尽可能用范围`for`语句。

## 3.4 迭代器介绍

只有少数几种标准库容器支持`[]`运算符，但所有标准库容器都支持迭代器。

### 3.4.1 使用迭代器

每种拥有迭代器的类型都拥有返回迭代器的成员。如`begin()`和`end()`。`begin()`返回指向第一个元素的迭代器，`end()`返回指向尾元素的下一位置的迭代器，即所谓的“**尾后（off the end）**”元素。如果容器为空，`begin()`和`end()`返回同一个迭代器，即尾后迭代器。

迭代器有`++`、`--`、`==`和`!=`等运算符。此外，类似指针，迭代器可以解引用：

```c++
*iter	//返回迭代器iter所指元素的引用
iter->mem	//解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem
```

被解引用或是递增、递减的迭代器必须合法，不能解引用、递增、递减非法迭代器和尾后迭代器。

解引用迭代器得到的是元素**的引用**，而不是元素本身。

在C++中，应当尽量使用迭代器而不是下标，而且在for循环的判断中最好使用`!=`而非`<`，因为迭代器和`!=`是每种标准库类型都支持的，而下标和`<`只有少部分类型支持。这当中蕴含着**泛型编程**的思想。

迭代器的类型是一种特殊的类型，可以使用`auto`进行自动推断。事实上，迭代器的类型包括`iterator`和`const_iterator`两种，前者可读可写，后置只读。如`vector<int>`的两种迭代器类型是`vector<int>::iterator`和`vector<int>::const_iterator`。`begin()`和`end()`可能返回`iterator`，也可能返回`const_iterator`，具体要看对象是否是常量。但我们在只读某些非常量对象时，可能希望使用`const_iterator`，此时可以使用C++ 11新引入的`cbegin()`和`cend()`。

“迭代器”这个名词有三种不同的含义：

- 迭代器 概念本身
- 容器定义的迭代器类型
- 某个迭代器对象

凡是使用了迭代器的循环体，都**不要**尝试改变迭代器所属的容器的大小。详见9.3.6节。

### 3.4.2 迭代器运算

`string`和`vector`还支持以下运算：

```c++
iter + n;
iter - n;
iter += n;
iter -= n;
iter1 - iter2;
>, >=, <, <=
```

例如，`vec.begin() + vec.size() / 2;`得到`vec`的中间位置的元素。

两个迭代器相减，得到一个`difference_type`类型的带符号整数，即所谓的“距离”。这一类型仍然取决于容器类型，如`vector<int>`的迭代器相减，得到`vector<int>::difference_type`。

使用迭代器的一个经典算法是二分搜索：

```c++
auto beg = text.begin(), end = text.end();
auto mid = text.begin() + (end - beg) / 2;
while (mid != end && *mid != sought) {
    if (sought < *mid)
        end = mid;
    else
        beg = mid + 1;
    mid = beg + (end - beg) / 2;
}
```

## 3.5 数组

数组与`vector`类似，但长度固定。在某些特殊的程序中**可能**有更好的运行时性能。数组是一种复合类型。数组中元素个数（称为“**维度**”）**也是**数组类型的一部分，在编译时必须是已知的。即元素个数必须是一个`constexpr`（见2.4.4节）。

```c++
constexpr unsigned sz = 42;
unsigned cnt = 42;
int arr1[sz];	//正确
int arr2[cnt];	//错误
```

默认情况下，数组的元素被默认初始化（见2.2.1节）。

定义时，不允许使用`auto`来通过初值类型推导数组类型。和`vector`一样，不存在由引用构成的数组。

允许在定义时对数组进行列表初始化，此时可以**省略**数组的维度，编译器将自动推导维度。如果此时指定了维度，其应当**不小于**初始值的个数。如果有盈余，盈余的元素被默认初始化。

C++标准**不允许**数组执行拷贝和用数组为其他数组赋值。

下面是一些包含指针和引用的数组声明。想要理解这类定义，最好的办法是从数组名开始按照由内向外的顺序阅读。

```c++
int *ptrs[10];		//ptrs是含有10个整型指针的数组
int &refs[10] = /* ? */;	//错误：不存在引用的数组
int (*Parray)[10] = &arr;	//Parray指向一个含有10个整数的数组
int (&arrRef)[10] = arr;	//arrRef引用一个含有10个整数的数组
int *(&arr)[10] = ptrs;	//arr是数组的引用，该数组含有10个指针
```

### 3.5.2 访问数组元素

使用下标时，通常将其定义为`size_t`类型，该类型定义于头文件`cstddef`。

### 3.5.3 指针和数组

数组和指针有天然的联系。在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。

```c++
int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
auto ia2(ia);	//ia2是一个整型指针，指向ia的首元素

decltype(ia) ia3 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};	//decltype不会产生上述转换，得到的是一个有10个元素的数组。
```

指针也可看做是一种迭代器。上面介绍的`string`和`vector`支持的迭代器运算，指针全部支持。注意尾后指针不能解引用，也不能递增。为了取得尾后指针，可以用：

```c++
int *e = &ia[10];
```

`ia[10]`这个不存在的元素的唯一作用就是用来初始化尾后指针。上面这种计算很容易出错，因此C++ 11引入了两个独立的函数`begin()`和`end()`，定义在`iterator`头文件中，用于返回作为参数的数组的头指针和尾后指针：

```c++
int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int *beg = begin(ia);
int *last = end(ia);
```

`begin()`对`std::vector`的一种可能的实现：

```c++
template <typename T>
inline T *begin(std::vector<T> &vec) {
    return vec.empty() ? nullptr : &vec[0];
}
```

和迭代器一样，两个相同类型的指针相减得到的值是它们的距离，类型是`ptrdiff_t`，和`size_t`类似。定义在`cstddef`中。

使用指针结合`[]`索引元素时，允许出现负值下标，只要这个下标对应的元素仍在索引区间内即可：

```c++
int ia[] = {0, 2, 4, 6, 8};
int *p = &ia[2];
int k = p[-2];	//k == ia[0]
```

C++内置的下标是一个带符号数，可以是负值，这与`string`和`vector`等标准库类型的无符号下标不同。

### 3.5.4 C风格字符串

本节大部分是对传统C字符串和`cstring`中函数的介绍，略去。

### 3.5.5 与旧代码的接口

由于各种原因，有大量使用C++编写的代码使用的是旧式的C风格字符串或数组。为了保证兼容，C++提供了一组功能。

在前面提到的`string`的用法中，凡是出现字符串字面值的地方都可以替换成一个C风格字符串。但不能反过来，即自动将`string`转为C风格字符串。为了实现这一功能，`string`提供了`c_str()`成员函数，参数为空，返回一个`const char *`。没人能保证这个指针在`string`对象改变后仍然有效，因此如果想一直使其可用，最好拷贝一份。

还可以使用数组初始化`vector`对象，只需指明待拷贝范围的头指针和尾后指针：

```c++
int int_arr[] = {0, 1, 2, 3, 4, 5};
vector<int> vec1(begin(int_arr), end(int_arr));	//拷贝整个数组
vector<int> vec2(int_arr + 1, int_arr + 4);	//拷贝int_arr[1]到int_arr[4]
```

总结：使用数组和C风格字符串很容易出错，所以现代C++应当尽可能使用标准库类型。

## 3.6 多维数组

严格来讲，C++没有多维数组，所谓的多维数组其实是数组的数组。

[接下来的内容大部分是介绍多维数组的初始化与使用，与C一致，故略。]

多维数组也可用范围for语句：

```c++
int ia[3][4] = {/*初始化*/};
for (auto &row : ia) {
    for (auto &col : row) {
        //statements
    }
}
```

使用范围`for`遍历多维数组时，变量一定要定义成引用，即使没有写操作，也要定义成`cosnt`引用。这是为了防止变量被自动转换为指针。若上面的代码中不定义成引用，`row`将是一个`int *`，内层for显然失去了意义，将无法通过编译。

