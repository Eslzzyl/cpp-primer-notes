## 4.1 基础

### 4.1.1基本概念

参加运算时，小整数类型（如`bool`、`char`、`short`等）通常会被**提升（promoted）**成较大的整数类型，主要是`int`。

#### 左值与右值

 C++的表达式要么是左值（`lvalue`），要么是右值（`rvalue`）。

当一个对象被用作右值的时候，用的是对象的值（内容）；当一个对象被用作左值的时候，用的是对象的身份（在内存中的位置）。

一个重要的原则是当要用到一个右值的时候，可以用一个左值来取代它（13.6节介绍了一种例外），反之则不可。当一个左值被当作右值使用时，实际使用的是它的内容（值）。

### 4.1.3 求值顺序

C++没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地。这实际上是在代码生成效率与程序潜在缺陷之间进行了权衡。

运算对象的求值顺序与优先级和结合律无关。

一些例子：

```c++
int i = f1() * f2();

int a = 0;
cout << a << " " << ++a << endl;
```

`f1()`和`f2()`一定会在乘法之前被调用，但是哪个先被调用是不确定的。如果`f1()`和`f2()`影响的对象没有交叉，那么无伤大雅；如果二者存在同时影响一个对象的情况，那么将产生未定义的行为。在不同的编译器中可能产生不同的结果。

同样，`<<`运算符并没有规定求值顺序，`++a`可能先于`a`执行，也可能是在`a`之后才执行。这是未定义的行为。

有4种运算符明确规定了运算对象的求值顺序：

- `&&`运算符，规定先求左侧的值，左侧为假结果立即为假，不再对右侧求值。
- `||`运算符，规定先求左侧的值，左侧为真结果立即为真，不再对右侧求值。
- `?:`（三目运算符）
- `,`（逗号运算符）

## 4.2 算术运算符

一元符号运算符对运算对象取负后，返回其（提升后的）副本。注意：

```c++
bool b = true;
bool b2 = -b;
```

这里`b2`的值是`true`。因为`bool`参与运算时被提升成`int`，取负结果为`-1`，`-1`显然是`true`的。

C++ 11规定除法运算中负的商一律向0取整，即直接切除小数部分。

C++ 11规定取模运算中模的符号和**被取模数**相等，商向0取整。一些例子：

```c++
21 / 6 == 3;
21 / 7 == 3;
-21 / -8 == 2;
21 / -5 == -4;
    
21 % 6 == 3;
21 % 7 == 0;
-21 % -8 == -5;
21 % -5 == 1;
```

## 4.4 赋值运算符

赋值运算符的左侧运算对象必须是一个**可修改的左值**。

C++ 11允许使用花括号括起来的初始值列表作为赋值运算符的右侧运算对象：

```c++
vector<int> vi = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
```

如果被赋值的是内置类型，则初始值列表只能包含一个元素；如果是类类型，赋值运算的细节由类本身指定。`vector`模板重载了赋值运算符使之可以接受列表赋值。

无论是什么类型，列表总可以是空的。此时将执行值初始化（见3.3.1节）。

赋值运算符满足右结合律，所以可以连写：

```c++
int a, b, c;
a = b = c = 0;
```

赋值运算符的优先级低于比较运算符，所以下面这种写法中的内层括号不可省略：

```c++
while ((i = get_valude()) != xxx)
```

复合赋值运算符包括`+=`、`-=`、`*=`、`/=`、`%=`、`<<=`、`>>=`、`&=`、`^=`等形式（后4个是位操作）。

注意：将`a = a + b`写作`a += b`可以少求一次`a`的值。

## 4.5 自增和自减运算符

C++中应该**优先**使用前缀形式的自增、自减运算符，**尽可能避免**后缀形式，因为后缀形式需要使用额外的空间保存变量。

后缀自增/自减运算符和`return`一同使用时，会先执行`return`。这意味着自增/自减白写了。

鼓励使用类似`*iter++`的简略写法。C++追求简洁。

## 4.6 成员访问运算符

箭头运算符作用于一个指针类型的运算对象，结果是一个左值。

点运算符分成两种情况：

1. 如果成员所属的对象是左值，那么结果是左值。
2. 如果成员所属的对象是右值，那么结果是右值。

## 4.7 条件运算符

条件运算符（`?:`）允许嵌套。比如下面的写法：

```c++
finalgrade = (grade > 90) ? "high pass" : (grade < 60) ? "fail" : "pass";
```

这条语句的意思是，如果`grade > 90`，则结果为`highpass`；否则判断`grade < 60`是否成立。若成立，结果为`fail`，否则结果为`pass`。

条件运算符是右结合的，这意味着右边的运算对象构成了左边运算对象的`:`分支。

条件运算符嵌套不要超过三层，否则可读性太差。

条件运算符的优先级很低，所以在嵌套使用时，务必加括号：

```c++
cout << ((grade < 60) : "fail" : "pass");	//输出pass或fail
cout << (grade < 60) ? "fail" : "pass";		//输出1或0
cout << grade < 60 ? "fail" : "pass";		//编译错误：试图比较cout和60
```

## 4.9 `sizeof`运算符

`sizeof`有两种写法：

```c++
sizeof(type);		//返回type类型的大小
sizeof expr;		//返回expr表达式结果的大小
```

例子：

```c++
char ch;
char *p = &ch;	//即使p不初始化，仍然可以得到下面的结果
sizeof(*p);		//结果为1
sizeof(p);		//结果为8（64位机）
sizeof *p;		//结果为1
sizeof p;		//结果为8
```

C++ 11允许使用`::`来使`sizeof`访问类成员的大小。如`sizeof Sales_data::revenue`得到的是`Sales_data`类中`revenue`成员的大小。

`sizeof`并不实际求运算对象的值，所以即使`p`是一个野指针，在`sizeof`中对其解引用仍然是安全的。使用`::`时同理，并不需要实例化一个对象，只使用类名即可得到结果。

对数组执行`sizeof`得到整个数组所占空间的大小。

对`vector`或`string`执行`sizeof`，得到的只是这些类的固定部分（非数据区）的大小，与存储了多少数据无关。具体结果要看编译器实现。在笔者的g++ 8.1上，`vector<int>`的`sizeof`结果恒为24。

`sizeof`的结果是一个`constexpr`，因此可以用`sizeof`的结果声明数组维度。

## 4.11 类型转换

### 显式转换（强制转换）

C++ 中的显式转换分 **命名的**强制类型转换 和旧式的从C继承的强制转换。

应当尽可能避免使用强制类型转换，每次使用都应该反复斟酌，考虑是否有替代方案。

一个命名的强制类型转换的形式如下：

`case-name<type>(expression);`

`cast-name`指定了执行是哪种转换，`type`是转换的目标类型，`expression`是要转换的值。若`type`是引用类型，则结果是左值。`cast-name`具体包括4种：

* `static_cast`
* `dynamic_cast`（支持运行时类型识别）
* `const_cast`
* `reinterpret_cast`

#### `static_cast`

任何具有明确定义的类型转换，只要不包含底层`const`，都可以使用`static_cast`。如使用下面的语句执行浮点除法：

```c++
double slope = static_cast<double>(j) / i;	//i、j均为整型
```

也可以使用`static_cast`找回存在于`void *`中的值：

```c++
void *p = &d;		//任何非常量对象的地址都能存进void*
double *dp = static_cast<double *>(p);
```

如果不使用类型转换而直接赋值，将产生未定义的后果。

#### `const_cast`

`const_cast`只能改变运算对象的底层`const`：

```c++
const char *pc;
char *p = const_cast<char *>(pc);
```

对于将常量对象转换成非常量对象的行为，我们一般称之为“去掉`const`性质”（cast away the const）。如果对象本身不是常量，去掉`const`后，可以进行写操作；如果对象是常量，执行写操作是未定义的。

`const_cast`只能用于改变表达式的常量属性，不能改变类型；使用其他形式的类型转换也不能改变表达式的常量属性。

`const_cast`多用于函数重载。

#### `reinterpret_cast`

偏底层且不常用，略

#### `dynamic_cast`

见19.2节。

