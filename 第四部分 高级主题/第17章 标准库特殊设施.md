标准库占据了C++ 11标准文本将近三分之二的篇幅。

## 17.1 `tuple`类型

`tuple`是类似`pair`的模板。`tuple`可以有多个成员，各个成员的类型也可以不同。

下表列出了`tuple`的操作。`tuple`和其伴随的函数都定义在头文件`tuple`中。

| 操作                                         | 描述                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| `tuple<T1, T2, ..., Tn> t;`                  | `t`是一个`tuple`，成员数为`n`，第`i`个成员的类型为`Ti`，所有成员进行值初始化 |
| `tuple<T1, T2, ..., Tn> t(v1, v2, ..., vn);` | 同上，所有成员使用初始值进行初始化。此构造函数是`explicit`的 |
| `make_tuple(v1, v2, ..., vn)`                | 返回一个用给定值初始化的`tuple`。`tuple`的类型将自动推断。   |
| `t1 == t2`与`t1 != t2`                       | 当两个`tuple`具有相同数量的成员且成员**对应**相等时，两`tuple`相等。这两个操作都使用`==`运算符完成。比较是短路的，即一旦发现有一个成员不等，就停止比较了。 |
| `t1`与`t2`比较                               | 大小关系的比较使用字典序。两个`tuple`必须具有相同数量的成员。比较使用`<`运算符。 |
| `get<i>(t)`                                  | 一个函数模板，返回`t`的第`i`个成员的引用：根据`t`的左/右值情况分别返回左/右值引用。 |
| `tuple_size<tupleType>::value`               | 一个类模板，通过一个`tuple`类型初始化。它有一个名为`value`的`public constexpr static`的数据成员，类型为`size_t`，表示给定`tuple`类型中成员的**数量**。 |
| `tuple_element<i, tupleType>::type`          | 一个类模板，`i`是整型变量，`tupleType`是一个`tuple`。它有一个名为`type`的`public`成员，表示给定`tuple`中指定成员的**类型**。 |

`tuple`的所有成员都是`public`的。

### 17.1.1 定义和初始化`tuple`

上表中`tuple`的第二个构造函数是`explicit`的，所以使用花括号初始化时，应该使用`tuple<size_t, size_t, size_t> three{1, 2, 3};`的写法，而不能写成`...three = {1, 2, 3};`。

访问`tuple`的成员只能使用名为`get`的标准库函数模板。模板实参指出要访问第几个成员（从0开始计数）。

```c++
auto book = get<0>(item);	//返回item的第一个成员
```

上表中的`tuple_element`中的`i`同样是从0开始计数的。

比较两个`tuple`有一定限制：对每对成员使用`==`或`<`都必须是合法的。比如不能将一个`tuple<string, string>`和一个`tuple<size_t, size_t>`比较，因为试图比较`size_t`和`string`是非法的。

### 17.1.2 使用`tuple`返回多个值

`tuple`的一个常见用途是从一个函数返回多个值。

## 17.2 `bitset`类型

`bitset`类用于处理二进制位运算。`bitset`具有固定大小，当我们定义一个`bitset`时，需要指出它包含多少个二进制位。`bitset`类定义在头文件`bitset`中。

| 操作                                  | 描述                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| `bitset<n> b;`                        | `b`有`n`位；每一位均为0。此构造函数是一个`constexpr`         |
| `bitset<n> b(u);`                     | `b`是`unsigned long long`值`u`的低`n`位的拷贝。如果`n`大于`unsigned long long`的大小，则`b`中超出的部分被置为0。此构造函数同样是一个`constexpr`。 |
| `bitset<n> b(s, pos, m, zero, one);`  | `b`是`string s`从位置`pos`开始`m`个字符的拷贝。`s`只能包含字符`zero`或`one`；如果`s`包含任何其他字符，构造函数抛出`invalid_argument`异常。字符在`b`中分别保存为`zero`和`one`。`pos`默认为0，`m`默认为`string::npos`，`zero`默认为`'0'`，`one`默认为`'1'` |
| `bitset<n> b(cp, pos, m, zero, one);` | 同上，但从`cp`指向的字符数组中拷贝字符。如果未提供`m`，则`cp`必须指向一个C风格字符串。如果提供了`m`，则从`cp`开始必须至少有`m`个`zero`或`one`字符 |

### 17.2.2 `bitset`操作

| 操作                            | 描述                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| `b.any()`                       | `b`中是否存在置位的二进制位                                  |
| `b.all()`                       | `b`中所有位都置位了吗                                        |
| `b.none()`                      | `b`中不存在置位的二进制位吗                                  |
| `b.count()`                     | `b`中置位的位数                                              |
| `b.size()`                      | 一个`constexpr`函数，返回`b`中的位数                         |
| `b.test(pos)`                   | 若`pos`位置的位是置位的，返回`true`，否则返回`false`         |
| `b.set(pos, v)`与`b.set()`      | 将位置`pos`处的位设置为`bool`值`v`。`v`默认为`true`。如果未传递实参，将`b`中所有位置位 |
| `b.reset(pos)`与`b.reset()`     | 将位置`pos`处的位复位或将`b`中所有位复位                     |
| `b.flip(pos)`与`b.flip()`       | 改变位置`pos`处的位的状态或改变`b`中每一位的状态             |
| `b[pos]`                        | 访问`b`中位置`pos`处的位；如果`b`是`const`的，则当该位 置位时`b[pos]`返回`true`，否则返回`false` |
| `b.to_ulong()`与`b.to_ullong()` | 返回一个`unsigned long`或一个`unsigned long long`值，其位模式与`b`相同。如果`b`中位模式不能放入指定的结果类型，抛出`overflow_error`异常 |
| `b.to_string(zero, one)`        | 返回一个`string`，表示`b`中的位模式。`zero`和`one`的默认值分别为0和1，用来表示`b`中的0和1 |
| `os << b`                       | 将`b`中二进制位打印为字符1或0，打印到流`os`                  |
| `is >> b`                       | 从`is`读取字符存入`b`。当下一个字符不是1或0时，或是已经读入`b.size()`个位时，读取过程停止 |

## 17.3 正则表达式

本节介绍C++ 11引入的正则表达式库（RE库）。它定义在头文件`regex`中。该库包含多个组件。

| 组件              | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| `regex`           | 表示有一个正则表达式的类                                     |
| `regex_match`     | 将一个字符序列与一个正则表达式匹配                           |
| `regex_search`    | 寻找第一个与正则表达式匹配的子序列                           |
| `regex_replace`   | 使用给定格式替换一个正则表达式                               |
| `sregex_iterator` | 迭代器适配器，调用`regex_search`来遍历一个`string`中所有匹配的子串 |
| `smatch`          | 容器类，保存在`string`中搜索的结果                           |
| `ssub_match`      | `string`中匹配的子表达式的结果                               |

余下内容待补

## 17.4 随机数

在C++ 11的随机数库引入之前，C++依赖C标准库中的`rand`函数来生成随机数。但`rand`存在弊端——它生成的数位于一个固定范围内，而为了改变这个范围以使其适合程序的需求时，往往会引入非随机因素。最后的结果就是`rand`的随机性不佳。

定义在头文件`random`中的随机数库通过一组协作的类来解决上面的问题：**随机数引擎类(random-number engines)**和**随机数分布类(random-number distribution)**。一个引擎类生成`unsigned`随机数序列，一个分布类使用一个引擎类生成指定类型的、在给定范围内的、服从特定概率分布的随机数。

当我们说**随机数发生器**时，指的是分布对象和引擎对象的组合。

### 17.4.1 随机数引擎和分布

随机数引擎是函数对象类，即重载了`()`运算符的类。该运算符返回一个随机的`unsigned`整数。

标准库定义了多个随机数引擎类，区别在于性能和随机性质量不同。每个编译器都会指定其中一个作为`default_random_engine`类型。下表列出了随机数引擎操作。

| 操作                  | 描述                                             |
| --------------------- | ------------------------------------------------ |
| `Engine e;`           | 默认构造函数，使用默认种子（由引擎类型决定）     |
| `Engine e(s);`        | 使用整型值`s`作为种子                            |
| `e.seed(s)`           | 使用种子`s`重置引擎的状态                        |
| `e.min()`和`e.max()`  | 此引擎可生成的最小值和最大值                     |
| `Engine::result_type` | 此引擎生成的`unsigned`整型类型                   |
| `e.discard(u)`        | 将引擎推进`u`步：`u`的类型为`unsigned long long` |

由引擎生成的随机数被称为**原始随机数**，它们一般不能直接使用，因为其范围往往不符合我们的需要。为了调整这个范围，需要使用分布类型。直接使用取模`%`进行范围调整会引入非随机因素。

#### 分布类型和引擎

```c++
//生成0到9之间（均包含）均匀分布的随机数
uniform_int_distribution<unsigned> u(0, 9);
default_random_engine e;
for (size_t i = 0; i < 10; ++i)
    cout << u(e) << " ";
```

分布类型同样是函数对象类。它的`()`运算符接受一个随机数引擎作为参数。注意传递的是引擎本身，不能写成`u(e())`，这代表将引擎生成的随机数传递给`u`，这会引起编译错误。

一个给定的随机数发生器总是生成同样的随机数序列。如果随机数发生器是函数的局部变量，则每次调用函数时，生成的会是同样的随机数序列。为了避免这个问题，可以将分布类型和引擎都定义成`static`的。

#### 设置随机数发生器种子

种子可以在创建引擎时提供，也可以调用引擎的`seed()`成员来更改。一个常用的种子是`time(0)`的返回值。该函数定义在头文件`ctime`中，接受一个指针，指向要写入时间的数据结构。如果提供的是空指针，函数简单地返回一个整型值。`time`的精度是秒。

### 17.4.2 其他随机数分布

我们经常会用到0到1之间的随机浮点数。对于`rand`函数生成的随机数，我们可以用结果除以`RAND_MAX`，得到一个随机数，但由于精度问题，有些浮点数永远都得不到。C++ 11的随机数库很好地解决了这个问题。

```c++
default_random_engine e;
uniform_real_distribution<double> u(0, 1);
for (size_t i = 0; i < 10; ++i)
   	cout << u(e) << " ";
```

| 操作                 | 描述                                                         |
| -------------------- | ------------------------------------------------------------ |
| `Dist d;`            | 默认构造函数。其他的构造函数依赖`Dist`的类型。分布类型的所有构造函数都是`explicit`的。 |
| `d(e)`               | 用相同的`e`连续调用`d`的话，会根据`d`的分布式类型生成一个随机数序列；`e`是一个随机数引擎对象 |
| `d.min()`与`d.max()` | 返回`d(e)`能生成的最小值和最大值                             |
| `d.reset()`          | 重建`d`的状态，使得随后对`d`的使用不依赖于`d`已经生成的值    |

不同的分布类型要么生成整数，要么生成浮点数。每个分布类型（有一个例外，见下）都有一个默认模板实参，如果我们希望使用该类型的默认生成类型，则不应在尖括号内写任何内容。比如`uniform_real_distribution<>`类型（默认）生成`double`。

#### 生成非均匀分布的随机数

C++ 11的随机数库还支持生成非均匀分布的随机数，比如正态分布。

`normal_distribution<> n(4, 1.5);`定义了一个分布对象，它生成均值为4、标准差为1.5的正态分布随机数序列。

#### `bernouli_distribution`类（伯努利分布）

这是随机数库中唯一一个非模板分布类。它是一个普通的类。它总是返回一个`bool`值，它返回`true`的概率是一个常数，其默认值是0.5。

## 17.5 IO库再探

本章进一步介绍IO库的三个更加特殊的特性：格式控制、未格式化IO和随机访问。

### 17.5.1 格式化输入与输出

标准库定义了一组操纵符(manipulator)来修改流的格式状态。`endl`就是一个操纵符。

有些操纵符可以接受参数。这些可以接收参数的操纵符都定义在头文件`iomanip`中。

当操纵符改变流的格式状态时，通常改变后的状态对所有后续IO都生效。所以改变格式状态的操纵符一般是成对的，一个改变状态，一个恢复状态。

#### 控制`bool`值的格式

默认情况下，`bool`值打印为0或1。我们可以通过对流使用`boolalpha`操纵符来覆盖这种格式：

```c++
cout << "default bool values: " << true << " " << false
     << "\nalpha bool values: " << boolalpha
     << true << " " << false << endl;
```

为了取消上面的改变，可以使用`noboolalpha`。

#### 指定整型值的进制

操纵符`hex`、`oct`、`dec`分别将接下来输出的整型值的格式改为十六进制、八进制和十进制（默认情况是十进制）。

一旦使用操纵符改变了进制格式，这种改变将持续，直到使用另一个进制格式操纵符。

#### 在输出中指定进制

使用`showbase`操纵符可以在输出结果中指定进制：

- 前导0x表示十六进制。
- 前导0表示八进制。
- 无前导字符串表示十进制。

使用`noshowbase`恢复之前的状态。

默认情况下，十六进制值会以小写打印，前导字符也是小写的`x`。我们可以通过使用`uppercase`操纵符来输出大写字母。使用`nouppercase`恢复之前的状态。

#### 控制浮点数格式

对浮点数输出格式的控制有3种：

1. 以多高精度（多少个数字）打印浮点值
2. 数值是打印为十六进制、定点十进制还是科学计数法形式
3. 对于没有小数部分的浮点值是否打印小数点

默认情况下，

- 浮点值按六位数字精度打印；
- 如果没有小数部分，则不打印小数点；
- 非常大和非常小的值打印为科学计数法形式，其他值打印为定点十进制格式。

#### 指定打印精度

默认情况下，浮点值按当前精度四舍五入而非截断。

我们可以通过调用IO对象的`precision`成员或使用`setprecision`操纵符来改变精度。`precision`成员函数是重载的。一个版本接受一个`int`值，将精度设置为此值，并返回旧精度值。另一个版本不接受参数，返回当前精度值。`setprecision`操纵符接受一个参数，用来设置精度。

例如，`cout.precision(12);`将`cout`流的打印精度设置为12位数字，`cout << setprecision(12);`实现同样的效果。

[此处略去一表]
