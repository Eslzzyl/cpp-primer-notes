本章介绍异常处理、命名空间和多重继承。

大规模程序设计对语言本身的要求更高。大规模程序设计的特殊要求包括：

- 在独立开发的子系统之间协同处理错误的能力。
- 使用各种库（可能包含独立开发的库）进行协同开发的能力。
- 对 比较复杂的应用概念建模的能力。

## 18.1 异常处理

### 18.1.4 `noexcept`异常说明

如果向编译器声明函数不会抛出异常，编译器就可以进行更加深入的优化。在C++ 11中，我们可以在函数形参列表后面加一个`noexcept`关键字来声明该函数不会抛出异常。

对于一个函数来说，`noexcept`要么出现在函数的**所有**声明语句和定义语句中，要么一次也不出现。

`noexcept`说明应当出现在函数的尾置返回类型之前。

对于成员函数，`noexcept`需要跟在`const`及引用限定符之后，而在`final`、`override`或虚函数的`=0`之前。

## 18.2 命名空间

多个库将名字放置在全局命名空间中将引发**命名空间污染(namespace pollution)**。

命名空间分割了全局命名空间，其中每个命名空间是一个作用域。

### 18.2.1 命名空间定义

命名空间的定义形式如下：

```c++
namespace [name] {
    //定义、声明等
}	//无需分号
```

只要能出现在全局作用域中的声明就能置于命名空间内，主要包括类、变量（及其初始化操作）、函数（及其定义）、模板和（嵌套的）其他命名空间。

命名空间可以定义在另一个命名空间中，但是不能定义在函数或类的内部。

#### 命名空间可以是不连续的

一个命名空间定义可以是定义一个新的命名空间，也可以是对原先已经存在的同名命名空间的扩展。这意味着命名空间的定义可以是不连续的。

#### 全局命名空间

全局作用域中定义的名字定义在**全局命名空间(global namespace)**。全局命名空间存在于所有程序中。下面的形式

`::mamber_name`

表示全局命名空间中的一个成员。

#### 内联命名空间

C++ 11引入了一种新的嵌套命名空间，称为内联命名空间(inline namespace)。内联命名空间中的名字可以被外层命名空间直接使用。

定义内联命名空间的方法是在`namespace`关键字前加`inline`。`inline`只需要出现在命名空间第一次出现的地方，之后对命名空间添加定义时可加也可不加。

#### 未命名的命名空间

未命名的命名空间(unnamed namespace)是指关键字`namespace`后紧跟花括号括起来的一系列声明语句。未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次使用前创建，并且直到程序结束才销毁。

一个未命名的命名空间可以在同一个文件中不连续，但是不能跨越多个文件。

未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同。

在C中，若想要某个名字对于整个文件都有效，需要将其定义为`static`的；C++使用未命名的命名空间实现这一效果。

### 18.2.2 使用命名空间成员

#### 命名空间的别名

我们可以为命名空间取一个短一些的别名：

`namespace primer = cplusplus_primer;`

这种声明语句必须出现在命名空间的定义之后。

别名支持嵌套：

`namespace Qlib = cpluscplus_primer::QueryLib;`

一个命名空间可以有多个别名。

#### `using`声明

一条`using`声明(using declaration)语句一次只引入命名空间的一个成员。它的有效范围从`using`声明的地方开始，一直到`using`声明所在的作用域结束为止。

`using`声明支持命名空间的简写形式。

#### `using`指示

`using`指示(using directive)即形如

`using namespace xxx;`

的写法。同样支持命名空间的简写形式。

建议使用`using`指示的场合只有一处：在命名空间本身的实现文件中建议使用`using`指示。除此之外，尽可能避免使用`using`指示。

#### 实参相关的查找与类类型形参

当我们向函数传递一个类类型的对象时，除了在常规的作用域查找外还会自动查找该实参（类）所属的命名空间。比如，使用`std::cin >> s`（`s`是`std::string`）时，其实是在调用`operator>>(std::cin, s)`。但我们不需要为`operator>>`提供`using`声明，这是因为`std::cin`和`s`都是类类型，编译器将自动查找`cin`和`s`所属的命名空间。

## 18.3 多重继承与虚继承

多重继承的派生类将继承所有父类的属性。

### 18.3.1 多重继承

多重继承的每个基类都可以提供访问说明符。如果缺省，则`class`默认是`private`，`struct`默认是`public`。

#### 派生类构造函数初始化所有基类

派生类的构造函数初始值列表将实参分别传递给每个直接基类。其中基类的构造顺序与派生列表中基类的出现顺序保持一致，而与派生类构造函数初始值列表中基类的顺序**无关**。