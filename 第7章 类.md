## 7.1 定义抽象数据类型

定义在类内部的函数是隐式的`inline`函数。定义在类外部的函数是默认的非`inline`函数。

我们通过在成员函数的参数列表后加一个`const`来表示这是一个**常量成员函数（const member function）**。这样定义使得传入到该函数的`this`指针是一个指向常量的指针，这就**禁止了该函数修改调用它的对象的数据成员**。此时函数对数据是只读的。

编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。因此成员函数可以随意使用类中的其他成员而无须在意它们出现的次序。

IO类不能被拷贝，所以将IO类作为参数传递时只能传引用。读取和写入的操作会改变流的内容，所以如果想要使用IO流，就应该使用普通引用，而非常量引用。

执行类的输出任务的函数应该尽量减少对格式的控制。比如不要有多余的换行。

### 7.1.4 构造函数

构造函数在`const`对象的构造过程中可以向其写值。直到构造函数完成初始化过程，对象才真正取得其“常量”属性。

#### 默认构造函数

编译器在某些情况下无法为类生成默认的构造函数。比如一个类中包含另一个类的对象作为成员变量，而该类没有默认构造函数，则编译器无法生成默认构造函数。还有一些情况见13.1.6节。

C++ 11中，如果我们自定义了构造函数，但又想保留原有的默认构造函数，可以使用`[类名]() = default;`的形式。`=default`既可以出现在类的内部，也可以作为定义的一部分出现在类的外部。

#### 构造函数初始值列表

如果构造函数的目的只是为类成员赋初始值的话，可以使用形式简洁的**构造函数初始值列表（constructor initialize list）**。其形式为在形参列表后跟一个冒号`:`，再跟各类成员的名字，其后加括号以赋初值。例子：

```c++
Sales_data(const std::string &s) : bookNo(s) {}
Sales_data(const std::string &s, unsigned n, double p)
    : bookNo(s), units_sold(n), revenue(p * n) {}
```

因为构造函数无需执行额外的操作，所以函数体为空。

### 7.1.5 拷贝、赋值和析构

除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。
