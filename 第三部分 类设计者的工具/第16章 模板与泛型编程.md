模板是C++泛型编程的基础。

## 16.1 定义模板

### 16.1.1 函数模板(function template)

模板定义以关键字`template`开始，后跟一个**模板参数列表(template parameter list)**，内含一个或多个**模板参数(template parameter)**，以逗号分隔。

使用模板时，我们（隐式地或显式地）指定**模板实参(template argument)**。

#### 实例化函数模板

我们调用一个函数模板时，编译器通常用函数实参来自动推断模板实参，从而为我们**实例化(instantiate)**一个特定版本的函数。这个特定版本的函数称为模板的**实例(instantiation)**。

#### 模板类型参数

**类型参数(type parameter)**前必须使用关键字`class`或`typename`。这两个关键字含义完全相同，可以互换使用。`typename`含义更加直观，但引入时间晚，很多程序员仍然习惯使用`class`。

#### 非类型模板参数

一个**非类型参数(nontype parameter)**表示一个值而非一个类型。我们通过一个特定的类型名而不是上面的两种关键字来指定非类型参数。

当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这个值必须是`constexpr`。

比如我们希望比较两个`const char []`，可以：

```c++
template<unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M]) {
    return strcmp(p1, p2);
}

compare("hi", "mom");
```

编译器会使用字面常量的大小来代替`N`和`M`。算上`\0`，编译器将实例化出如下版本：

```c++
int compare(const char (&p1)[3], const char (&p2)[4])
```

#### `inline`和`constexpr`的函数模板

函数模板可以声明成`inline`和`constexpr`的。这两个关键字须置于模板参数列表后。

```c++
template <typename T> inline T min(const T&, const T&);
```

#### 模板编译

当我们使用（而不是定义）模板时，编译器才生成代码。

为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，模板函数的声明和定义一般一起放在头文件中。

### 16.1.2 类模板(class template)

当我们**使用**一个类模板时，必须提供额外信息，如`vector<int>`中的`int`，这些信息称为**显式模板实参(explicit template argument)**列表。编译器使用它们实例化出不同的类。

一个类模板的每个实例都形成一个独立的类。

定义在类模板之外的成员函数必须使用`template`关键字。因为模板参数列表也是模板类类型的一部分，所以使用类名时必须带上它。

```c++
template<typename T>
int Blob<T>::example_func(...) {
    //...
}
```

在类模板自己的作用域中，我们可以直接使用模板名而无需提供实参。

C++ 11允许我们为类模板定义类型别名：

```c++
template<typename T> using twin = pair<T, T>;
twin<string> authors;	//authors是一个pair<string, string>
twin<int> win_loss;	//win_loss是一个pair<int, int>
twin<double> area;	//area是一个pair<double, double>
```

类模板也可以有`static`成员。每个类模板实例将有自己的`static`成员实例。

### 16.1.3 模板参数

C++假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用形如`T::size_type *p;`的语句声明指针时，可能得不到想要的结果。此时需要使用`typename`：`typename T::size_type *p;`

C++ 11允许为函数和类模板提供默认模板实参(default template argument)。

如果一个模板类为所有模板参数都提供了默认实参，且使用时希望应用这些默认的实参，那么仍然需要给出尖括号`<>`：

```c++
template <class T = int> class Numbers {...};
Numbers<long double> lots_of_precision;
Numbers<> average_precision;
```

一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置。

### 16.1.4 成员模板

