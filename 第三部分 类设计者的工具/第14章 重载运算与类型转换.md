## 14.1 基本概念

重载的运算符本质是具有特殊名字的函数。它的参数数量与其作用的运算对象数量一样多。对二元运算符而言，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个。

对一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数。这意味着我们不能重载对内置类型的运算符。当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象，且自动绑定到该对象的`this`。此时运算符函数的显式参数数量比运算对象的数量少一个。

只能重载已有的运算符，不能发明创造新的运算符。

对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致。

```c++
//非成员函数
data1 + data2;
operator+(data1, data2);

//成员函数
data1 += data2;
data1.operator+=(data2);
```

#### 某些不应该重载的运算符

逻辑与`&&`、逻辑或`||`、逗号`,`、取地址`&`运算符最好不要重载，尽管它们都是允许重载的。

#### 使用与内置类型一致的含义

我们应该只重载那些含义非常明了且无二义性的运算符。

#### 选择作为成员或者非成员

一些准则：

- 赋值`=`、下标`[]`、调用`()`和成员访问箭头`->`运算符必须是成员。
- 符合赋值运算符一般来说应该是成员，但不是必须。
- 改变对象状态的运算符或者与给定类型密切相关的运算符，如`++`、`--`和解引用`*`，通常应该是成员。
- 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。

`string`重载了`+`，且`operator+`是成员函数，这意味着当我们写`s + "abc"`时，等价于调用`s.operator+("abc")`，显然这个顺序不能反过来。这就是不能把`string`加到`const char *`上的原因。

## 14.2 输入和输出运算符

### 14.2.1 重载输出运算符`<<`

通常情况下，输出运算符的第一个形参是一个**非常量**`ostream`对象的**引用**（向流写数据会改变流，流不能拷贝）。第二个形参一般是一个（我们想要打印的类类型的）常量的引用。

`operator<<`一般要返回它的`ostream`形参。

输出运算符要尽量减少格式化操作。

输出运算符必须是非成员函数，否则，它的左侧运算对象将是一个类的对象，而不是我们想要的`ostream`了。而它又需要读类的数据，所以往往是友元。

### 14.2.2 重载输入运算符`>>`

输入运算符的第一个形参一般是输入流的引用，第二个形参是将要读入到的（非常量）对象的引用，函数返回流的引用。

输入运算符必须处理可能失败的情况，而输出运算符不需要。我们一般先一次性读入所有数据，然后检查流的状态，若正常则照常执行赋值，否则将要读入到的对象赋一个默认值。

## 14.3 算数和关系运算符

我们通常把算数和关系运算符定义成 非成员函数，以允许交换律。形参往往是常量的引用，因为我们不需要改变运算对象。

函数对两个参数进行某种运算，然后返回运算结果对象（一般定义成函数内的局部变量）的副本。

### 14.3.1 相等运算符

如果要比较同一个类的两个对象的相等性，我们最好重载`==`运算符，而不是仅仅弄一个普通的命名函数。这样一方面便于用户使用，另一方面可以支持一些标准库容器和泛型算法。

重载的`==`应该具有传递性。即如果有`a==b`，`b==c`，那么就应该有`a==c`。

一般重载了`==`的类应该同时也重载`!=`。这两个运算符中的一个应该把工作委托给另一个，即一个函数完成实际的比较，另一个函数只是调用它然后返回对结果的取非运算而已。

### 14.3.2 关系运算符

定义了相等运算符的类也常常（但不是总是）会定义关系运算符。关联容器和一些泛型算法会用到小于`<`运算符，所以`operator<`比较有用。

如果一个类同时定义了`==`，那么关系运算符应该与其保持一致，也就是说，如果两个对象不等，那么总应该有一个对象`<`另一个对象。

## 14.4 赋值运算符

`vector`支持使用花括号赋值。其实现大致如下：

```c++
class vector {
public:
	vector &operator=(std::initializer_list<std::string>);	//只针对string
};
```

赋值运算符必须定义成类的成员，复合赋值运算符通常也应该这样做，但不是一定。

## 14.5 下标运算符

下标运算符`[]`必须是成员函数。

下标运算符通常以所访问的元素的引用作为返回值，而且最好分别定义常量和非常量版本，当作用于一个常量对象时，返回常量引用来阻止我们为对象赋值。

一个例子：

```c++
class StrVec {
public:
    std::string &operator[](std::size_t n)
    	{ return elements[n]; }
    const std::string &operator[](std::size_t n) const
    	{ return elements[n]; }
private:
    std::string *elements;
};
```

## 14.6 递增和递减运算符

C++不要求递增/递减运算符必须是类的成员，但是通常建议将其设为类的成员。而且我们应该同时定义前缀和后缀版本。

前置运算符应该返回递增或递减后对象的引用。

后置运算符应该返回对象的原值（递增/减前的值），返回的形式是值而不是引用。

#### 区分前置和后置运算符

为了解决这个问题，后置版本接受一个额外的（不被使用的）`int`类型的形参。我们使用后置运算符时，编译器传入一个值为`0`的实参。这样，前置版本的参数列表为空，后置版本的参数列表有一个`int`，就可以进行函数匹配。

上文的`int`唯一的作用就是区分前/后置，所以我们不使用它，也就不用为这个参数命名。

```c++
StrBlobPtr operator++(int);	//后置
StrBlobPtr operator--(int);
StrBlobPtr& operator++();	//前置
StrBlobPtr& operator--();
```

我们一般将主要的操作放在前置版本，后置版本只是在此基础上添加一些简单的操作。

```c++
StrBlobPtr StrBlobPtr::operator++(int)	//后置
{
    StrBlobPtr ret = *this;	//保存递增前的状态
    ++*this;	//调用前置版本
    return ret;	//返回递增前的状态
}
```

我们可以显式地调用递增/减运算符：

```c++
StrBlobPtr p(...);
p.operator++(0);	//后置
p.operator++();		//前置
```

我们传入的`0`的唯一作用就是区分前/后置版本。

## 14.7 成员访问运算符

成员访问运算符（`*`、`->`）常用于迭代器类和智能指针类。

箭头运算符`->`必须是类的成员，解引用运算符`*`最好也是。

我们一般将`->`的工作委托给`*`。

## 14.8 函数调用运算符

如果类重载了函数调用运算符，则我们可以像使用函数一样调用该类的对象。这样的对象称为**函数对象(function object)**。

函数调用运算符必须是成员函数。类可以定义多个函数调用运算符，不同的版本应该在参数数量和类型上有所区别。

一个例子：

```c++
class PrintString {
public:
    PrintString(ostream &o = cout, char c = ' ') : os(o), sep(c) { }
    void operator()(const string &s) const { os << s << sep; }
private:
    ostream &os;
    char sep;
};

... {
    PrintString printer;	//使用默认值，打印到cout
    printer(s);	//在cout中打印s，后面跟一个空格
    PrintString errors(cerr, '\n');
    errors(s);	//在cerr中打印s，后面跟一个换行符
}
```

函数对象常常用于泛型算法的实参。比如我们可以将`for_each`和上面的`PrintString`结合使用，按我们自己的方式打印容器的内容。

### 14.8.1 lambda是函数对象

`lambda`本质是函数对象。

### 14.8.2 标准库定义的函数对象

标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类都定义了调用运算符。

| 算术            | 关系               | 逻辑             |
| --------------- | ------------------ | ---------------- |
| `plus<T>`       | `equal_to<T>`      | `logical_and<T>` |
| `minus<T>`      | `not_equal_to<T>`  | `logical_or<T>`  |
| `mulpiplies<T>` | `greater<T>`       | `logical_not<T>` |
| `divides<T>`    | `greater_equal<T>` |                  |
| `modules<T>`    | `less<T>`          |                  |
| `negate<T>`     | `less_equal<T>`    |                  |

### 14.8.3 可调用对象与`function`

可调用对象有类型，每个lambda有它自己唯一的（匿名）类类型；函数及函数指针的类型则由其返回值类型和实参类型决定。

类型不同的可调用对象可能共享同一种**调用形式(call signature)**。一种调用形式对应一个函数类型。如：`int(int, int)`是一个函数类型，它接受两个`int`，返回一个`int`。

为了调用具有相同调用形式的可调用对象，我们考虑定义一个**函数表(function table)**，其由一系列可调用对象的指针构成。函数表一般是用`map`实现的。例：

```c++
map<string, int(*)(int, int)> binops;
binops.insert({"+", add});	//{"+", add}是一个pair
```

其中`add`是一个指向正确类型函数的指针。这个函数表接受两个`int`，返回一个`int`。

但是这种实现有一个问题：只能向`map`中加入函数指针，lambda表达式不行。因为每个lambda表达式都有自己的类型，即使它也是接受两个`int`，返回一个`int`。

为了解决这个问题，C++ 11引入了一个名为`function`的模板类。该类定义于`functional`头文件。

| 操作                      | 描述                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `function<T> f;`          | `f`是一个用来存储可调用对象的空`function`，这些可调用对象的调用形式应该与函数类型`T`相同 |
| `function<T> f(nullptr);` | 显式地构造一个空`function`                                   |
| `function<T> f(obj);`     | 在`f`中存储可调用对象`obj`的副本                             |
| `f`                       | 将`f`作为条件：当`f`含有一个可调用对象时为真；否则为假       |
| `f(args)`                 | 调用`f`中的对象，参数是`args`                                |

定义为`function<T>`的成员类型：

| 类型                                                         | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `result_type`                                                | 该`function`类型的可调用对象返回的类型                       |
| `argument_type`、`first_argument_type`、`second_argument_type` | 当`T`有一个或两个实参时定义的类型，如果`T`只有一个实参，则`argument_type`是该类型的同义词；如果有两个，则分别对应`first_argument_type`和`second_argument_type` |

