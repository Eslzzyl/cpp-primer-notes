当定义一个类时，我们显式或是隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作：

- 拷贝构造函数（copy constructor）
- 拷贝赋值运算符（copy-assignment operator）
- 移动构造函数（move constructor）
- 移动赋值运算符（move-assignment operator）
- 析构函数（destructor）

如果没有显式地定义这些成员，则编译器自动定义缺失的操作。

## 13.1 拷贝、赋值与销毁

### 13.1.1 拷贝构造函数

如果一个构造函数：

1. **第一个**参数是自身类型的引用，且任何额外参数都有默认值；
2. 或：只有一个参数，即自身类型的引用；

则此构造函数是拷贝构造函数。其中，自身类型的引用一般是`const`的。拷贝构造函数有时会被隐式使用，所以不应该是`explicit`的。

#### 合成拷贝构造函数

即使我们定义了其他构造函数，没有定义拷贝构造函数时，编译器也会自动合成一个。一般情况下，合成的拷贝构造函数将给定对象的每个非`static`成员拷贝到正在创建的对象中。内置成员直接拷贝，类类型的成员使用它的拷贝构造函数。数组也会自动地逐个元素地拷贝过去。

#### 拷贝初始化

一般地，使用小括号的是直接初始化，使用等号的是拷贝初始化。

使用**直接初始化**时，我们实际上是要求编译器使用普通的重载函数匹配来选择构造函数。

使用**拷贝初始化**时，编译器实际上是将等号右侧对象拷贝到正在创建的对象中，还可能需要类型转换。此外还有一些适用的情况：

- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类（7.5.5节）中的成员

拷贝初始化通常依赖拷贝构造函数，然而有时会使用移动构造函数。

我们初始化标准库容器或是使用它们的`insert()`或`push()`成员时，容器会进行拷贝初始化。与之相对，使用`emplace()`时，执行的是直接初始化。

#### 编译器可以绕过拷贝构造函数

拷贝初始化时，编译器可以（但不是必须）绕过拷贝/移动构造函数，使用直接初始化。但即使这样，仍然要求拷贝/移动构造函数是存在且可访问的。

### 13.1.2 拷贝赋值运算符