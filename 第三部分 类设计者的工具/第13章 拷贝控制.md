当定义一个类时，我们显式或是隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作：

- 拷贝构造函数（copy constructor）
- 拷贝赋值运算符（copy-assignment operator）
- 移动构造函数（move constructor）
- 移动赋值运算符（move-assignment operator）
- 析构函数（destructor）

如果没有显式地定义这些成员，则编译器自动定义缺失的操作。

## 13.1 拷贝、赋值与销毁

### 13.1.1 拷贝构造函数

如果一个构造函数：

1. **第一个**参数是自身类型的引用，且任何额外参数都有默认值；
2. 或：只有一个参数，即自身类型的引用；

则此构造函数是拷贝构造函数。其中，自身类型的引用一般是`const`的。拷贝构造函数有时会被隐式使用，所以不应该是`explicit`的。

#### 合成拷贝构造函数

即使我们定义了其他构造函数，没有定义拷贝构造函数时，编译器也会自动合成一个。一般情况下，合成的拷贝构造函数将给定对象的每个非`static`成员拷贝到正在创建的对象中。内置成员直接拷贝，类类型的成员使用它的拷贝构造函数。数组也会自动地逐个元素地拷贝过去。

#### 拷贝初始化

一般地，使用小括号的是直接初始化，使用等号的是拷贝初始化。

使用**直接初始化**时，我们实际上是要求编译器使用普通的重载函数匹配来选择构造函数。

使用**拷贝初始化**时，编译器实际上是将等号右侧对象拷贝到正在创建的对象中，还可能需要类型转换。此外还有一些适用的情况：

- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类（7.5.5节）中的成员

拷贝初始化通常依赖拷贝构造函数，然而有时会使用移动构造函数。

我们初始化标准库容器或是使用它们的`insert()`或`push()`成员时，容器会进行拷贝初始化。与之相对，使用`emplace()`时，执行的是直接初始化。

#### 编译器可以绕过拷贝构造函数

拷贝初始化时，编译器可以（但不是必须）绕过拷贝/移动构造函数，使用直接初始化。但即使这样，仍然要求拷贝/移动构造函数是存在且可访问的。

### 13.1.2 拷贝赋值运算符

除了初始化外，类还可以控制其对象如何赋值。如果没有定义自己的拷贝赋值运算符，编译器同样会自动合成一个。

#### 重载赋值运算符

有关重载运算符的详细内容，请参照14章。

重载运算符本质上是函数。赋值运算符就是一个名为`operator=`的函数。

拷贝赋值运算符接受一个与其所在类相同类型的参数。

```c++
class Foo {
public:
    Foo &operator=(const Foo&);
    //...
};
```

赋值运算符通常返回一个指向其左侧运算对象的引用。

#### 合成拷贝赋值运算符

由编译器自动合成的拷贝赋值运算符的行为与合成的拷贝构造函数类似，都是逐个拷贝类的成员。

```c++
Sales_data&
Sales_data::operator=(const Sales_data &rhs) {
    bookNo = rhs.bookNo;
    units_sold = rhs.units_sold;
    revenue = rhs.revenue;
    return *this;
}
```

### 13.1.3 析构函数

析构函数负责释放对象使用的资源，并销毁对象的非`static`成员。

析构函数的名字由波浪号`~`接类名构成。它同样无返回值，此外它还没有参数。

析构函数不可重载（因为它没有参数）。一个类只会有一个析构函数。

#### 析构函数完成什么工作

在一个析构函数中，首先执行函数体，**然后**销毁成员，销毁顺序是初始化顺序的**逆序**。

注意：析构过程不是在函数体完成的，而是在函数体执行结束**后**隐式执行的，这一点非常重要。

析构过程是隐式的，因而没有像构造函数初始值列表之类的东西。对于类类型的成员（智能指针属于这个范畴），调用它们各自的析构函数；对于指针，只销毁指针本身，不销毁指针所指向的对象。

#### 什么时候会调用析构函数

- 变量在离开其作用域时被销毁。
- 当一个对象被销毁时，其成员被销毁。
- 容器（标准库容器/数组）被销毁时，其元素被销毁。
- 对于动态分配的对象，对指向它的指针应用`delete`时，销毁。
- 对于临时对象，当创建它的完整表达式结束时被销毁。

### 13.1.4 三/五法则

拷贝构造函数、拷贝赋值运算符和析构函数是控制类的拷贝的三种基本操作。移动构造函数、移动赋值运算符是控制类的移动的两种基本操作。这五种操作一般要么都需要定义，要么都不用定义。其中在拷贝三操作中，一般先考虑析构函数。如果拷贝是非必要的，使用移动会避免一些开销。

### 13.1.6 阻止拷贝

有些类需要阻止拷贝和赋值的操作，因为它们没有意义。一个典例是`iostream`。

#### 定义删除的函数

C++ 11下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为**删除的函数(deleted function)**来阻止拷贝。这类函数虽然被声明了，但不能被使用。其声明方式为在参数列表后面加上`=delete`。

与`=default`不同，`=delete`必须出现在函数第一次声明的时候。此外，我们只能对编译器能够自动合成的函数使用`=default`，但是对任何函数都可以使用`=delete`。

#### 析构函数不能删除

如题。删除类的析构函数可以通过编译，但这样的类不能用于生成任何对象。并且这种影响会波及到将该类作为成员的更大的类。

#### 合成的拷贝控制成员可能是删除的

在某些情况下，编译器合成的拷贝控制成员会声明为删除的。

- 当该类的某个**成员**的**析构函数**是删除的或不可访问的时，类的合成**析构函数**将是删除的；
- 当该类的某个**成员**的**拷贝构造函数**是删除的或不可访问的时，类的合成**拷贝构造函数**将是删除的。
- 当该类的某个**成员**的**拷贝赋值运算符**是删除的或不可访问的时，或是类有一个`const`成员或引用成员时，类的合成**拷贝运算符**将是删除的。
- 如果类的某个**成员**的**析构函数**是删除的或不可访问的，或是类有一个缺少类内初始化器的引用成员，或是类有一个缺少类内初始化器且未显式定义默认构造函数的`const`类成员时，类的**默认构造函数**被定义为删除的。

#### `private`拷贝控制

旧标准中，类通过将拷贝控制函数声明为`private`的来阻止拷贝。新标准应该使用`=delete`。

## 13.2 拷贝控制和资源管理

类的拷贝操作可以使类表现得像两种对象：**值**或**指针**。

标准库容器和`string`的行为像是一个值，而`shared_ptr`的行为像一个指针。不允许拷贝的IO类和`unique_ptr`的行为既不像值也不像指针。

### 13.2.1 行为像值的类

#### 类值拷贝赋值运算符

赋值运算符通常组合了析构函数和构造函数的操作。赋值操作会销毁左侧运算对象的资源并从右侧运算对象拷贝数据。

如果可能，我们要保证运算符是异常安全的。

赋值运算符的好的模式是：先将右侧运算对象拷贝到一个局部临时对象中。拷贝完后，销毁左侧运算对象的现有成员。随后将临时对象中的数据拷贝到左侧运算对象。这种模式下，将一个对象赋值给自己时不会出现问题。

### 13.2.2 行为像指针的类

#### 引用计数

引用计数的工作方式如下：

- 除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1。
- 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享。
- 析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。
- 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。

计数器一般放在动态内存种，当拷贝或赋值对象时，我们拷贝指向计数器的指针。这样可以做到共享。

为了处理自赋值的情况，我们先递增右侧运算对象的计数器，再递减左侧运算对象的计数器。

## 13.3 交换操作

管理资源的类通常还定义一个名为`swap`的函数。对于那些与重排算法一起使用的类，定义`swap`是非常重要的。这类算法在交换两个元素时会调用`swap`。如果自定义了`swap`函数，则使用自定义的；否则会使用标准库的`std::swap`（定义于头文件`utility`中）。

显然为了实现交换，我们需要进行一次拷贝与两次赋值。

#### 编写我们自己的`swap`函数

典型的`swap`实现如下：

```c++
class HasPtr {
    friend void swap(HasPtr&, HasPtr&);
    //...
};
inline void swap(HasPtr &lhs, HasPtr &rhs)
{
    using std::swap;
    swap(lhs.ps, rhs.ps);
    swap(lhs.i, rhs.i);
}
```

[内容待补]

#### 在赋值运算符中使用`swap`

定义`swap`的类通常用`swap`来定义它们的赋值运算符。

```c++
HasPtr& HasPtr::operator=(HasPtr rhs)
{
    swap(*this, rhs);	//rhs现在指向本对象曾经使用的内存
    return *this;	//rhs被销毁
}
```

这个技术的有趣之处在于它自动处理的自赋值情况并且天然就是异常安全的。

## 13.6 对象移动

标准库容器、`string`和`shared_ptr`既可以移动也可以拷贝。IO类和`unique_ptr`只能移动，不能拷贝。

### 13.6.1 右值引用

为了支持移动操作，C++ 11引入了**右值引用(rvalue reference)**，即必须绑定到右值的引用。我们通过`&&`而不是`&`来获得右值引用。右值引用只能绑定到一个将要销毁的对象。

有关左值/右值，请参见4.1.1节。

常规的引用又称**左值引用(lvalue reference)**，右值引用有着与左值引用完全相反的绑定特性。

```c++
int i = 42;
int &r = i;		//正确：r引用i
int &&rr = i;	//错误：不能将右值引用绑定到左值上
int &r2 = i * 42;	//错误：i*42是一个右值
const int &r3 = i * 42;	//正确：可以将const的引用绑定到一个右值上
int &&rr2 = i * 42;	//正确
```

左值引用可绑定的对象并不仅限于变量，而是各类左值。诸如返回非引用类型的函数、赋值、下标、解引用和前置递增/递减运算符等。

右值引用不能绑定到变量，因为变量是左值。即使这个变量本身是一个右值引用也不行。

#### 左值持久；右值短暂

左值有持久的状态，右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。

右值引用所引用的对象：

- 将要被销毁；
- 没有其他用户。

这意味着使用右值引用的代码可以自由地接管对象的资源。

#### 标准库`move`函数

我们可以显式地将一个左值转换为对应的右值引用类型。我们还可以调用标准库函数`move`来获得绑定到左值上的右值引用。

```c++
int &&rr3 = std::move(rr1);		//正确，move返回右值引用
```

`move`调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。我们可以销毁一个移后源对象，也可以赋予它一个新值，但不能使用它的值。

使用标准库`move`的代码应当直接在调用处写`std::move`，不宜使用`using`声明。这样可以避免潜在的名字冲突。

### 13.6.2 移动构造函数和移动赋值运算符

我们可以为自己的类定义**移动构造函数**和移动赋值运算符，以支持移动操作。

移动构造函数的第一个参数是该类类型的**右值**引用，且任何额外的参数（如果有）必须带默认值。

除了完成资源移动，移动构造函数还必须确保移动后源对象处于这样一个状态——销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源——这些资源的所有权已经归属新创建的对象。

#### 移动操作、标准库容器和异常

移动操作通常不分配资源，也就通常不会抛出异常。C++ 11允许在函数的形参列表后附加`noexcept`关键字来表示我们保证此函数不会发生异常。详细介绍请见18.1.4节。

在一个构造函数中，`noexcept`位于形参列表和初始化列表开始的冒号之间。

我们必须在类头文件的声明和定义中（如果定义在类外的话）都指定`noexcept`。

#### 移动赋值运算符

一个例子：

```c++
StrVec &StrVec::operator=(StrVec &&rhs) noexcept
{
    //直接检测自赋值情况
    if (this != rhs) {
        free();	//释放已有元素
        //从rhs接管资源，此处只给出一条语句
        elements = rhs.elements;
        //...
        //将rhs置于可析构状态
        rhs.elements = rhs.first_free = rhs.cap = nullptr;
    }
    return *this;
}
```

#### 合成的移动操作

编译器同样会合成移动构造函数和移动赋值运算符，不过不是对所有类都会合成。

只有一个类没有定义任何自己版本的拷贝控制成员，且类的每个非`static`数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。

如果一个类没有移动操作，类会使用对应的拷贝操作来替代。

如果一个类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的**合成**拷贝构造函数和拷贝赋值运算符会被定义为删除的（仍然可以自己定义）。

#### 移动右值，拷贝左值

如果一个类既有移动构造函数，也有拷贝构造函数，则编译器使用普通的函数匹配来确定使用哪个构造函数。一般的原则是对右值使用移动，对左值使用拷贝。

```c++
StrVec v1, v2;
v1 = v2;		//v2是左值，使用拷贝
StrVec getVec(istream &);	//getVec返回一个右值
v2 = getVec(cin);	//使用移动赋值
```

不过，如果没有移动构造函数，则右值也被拷贝。例如，`Foo`类没有移动构造函数，则下面的代码使用拷贝。

```c++
Foo x;
Foo y(x);		//拷贝，x是一个左值
Foo z(std::move(x));	//使用&&x（右值引用）初始化，匹配的是拷贝构造函数
```

#### 移动迭代器

C++ 11提供了一种**移动迭代器(move iterator)**适配器。一般的迭代器解引用得到一个左值引用，而移动迭代器解引用得到一个右值引用。

我们调用标准库的`make_move_iterator`函数将一个普通迭代器转换为一个移动迭代器。此函数接受普通迭代器作为参数，返回对应的移动迭代器。

注意：不要随意使用移动操作。在用户接口代码中使用移动操作要尤其小心，三思而后行。这是因为一个移后源对象具有不确定的状态，如果还有别的用户要用，就可能出问题。

### 13.6.3 右值引用和成员函数

区分移动和拷贝的重载函数要看参数。移动函数的参数一般是`T&&`，拷贝函数的参数一般是`const &`。

C++在语法上允许对一个右值赋值：

```c++
s1 + s2 = "wow!";
```

但我们常常不希望这样做。我们可以通过**引用限定符(reference qualifer)**来强制赋值号的左侧运算对象（即`this`指向的对象）是一个左值。方法是在相应函数的参数列表后防止一个引用符号：

```c++
Foo &operator=(const Foo&) &;
```

引用限定符可以是`&`或`&&`，分别指出`this`可以指向一个左值或右值。引用限定符只能用于非`static`成员函数，且必须同时出现在函数的声明和定义中。