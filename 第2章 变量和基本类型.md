## 2.1 基本内置类型

C++定义了一套包括**算术类型**（arithmetic type）和**空类型**（void）在内的数据类型。

### 2.1.1 算术类型

算术类型分两类：整型（integral type，包括字符型和bool型）和浮点型。

下表列出了C++标准规定的尺寸的最小值，允许编译器实现更大的尺寸。

| 类型        | 含义           | 最小尺寸     |
| ----------- | -------------- | ------------ |
| bool        | 布尔类型       | 未定义       |
| char        | 字符           | 8 bit        |
| wchar_t     | 宽字符         | 16 bit       |
| char16_t    | Unicode字符    | 16 bit       |
| char32_t    | Unicode字符    | 32 bit       |
| short       | 短整型         | 16 bit       |
| int         | 整型           | 16 bit       |
| long        | 长整型         | 32 bit       |
| long long   | 长整型         | 64 bit       |
| float       | 单精度浮点数   | 6位有效数字  |
| double      | 双精度浮点数   | 10位有效数字 |
| long double | 扩展精度浮点数 | 10位有效数字 |

C++规定，长度：short <= int <= long <= long long

long long是C++ 11新定义的。

除了bool型和字符型之外，整形可以分为**带符号的**（signed）和**无符号的**（unsigned）两种。

字符型有三种：char、signed char、unsigned char。实际表现出来的char只有后两种，第一种由编译器决定实现为后两者中的其中一种。

选用类型的经验准则：

* 明确知晓值不可能为负值时，使用无符号类型。
* 使用int执行整数运算，如果int太小，使用long long。
* 进行整数运算时不要用char或bool。因为char在有些机器上是有符号，在另一些机器上是无符号的。如果需要使用一个不大的整数，应当指明unsigned char或signed char。
* 进行浮点运算时使用double，而不用float。float的精度一般不够，而且float和double的运算成本相差无几。某些机器运算double甚至比float更快。long double一般不用。

类型转换（只记录了笔者不熟悉的规则）：

* 将bool转换为非bool类型时，bool为false则结果为0，bool为true则结果为1。
* 赋给无符号类型一个超出它表示范围的数时，结果为该数对该类型能表示的最大值取模。如unsigned char可以表示0~255，赋值>=256时，结果为该值对256取模。如果赋了一个负数，结果等于该类型表示的最大值减去该负数。
* 赋给带符号类型一个超出它表示范围的值时，结果是**未定义的**（undefined）。程序可能继续工作，可能崩溃，也可能生成垃圾数据。

### 2.1.3 字面值常量

C++的转义序列：

| 转义序列 | 含义           |
| -------- | -------------- |
| \n       | 换行符         |
| \v       | 纵向制表符     |
| \\       | 反斜线         |
| \r       | 回车符         |
| \t       | 横向制表符     |
| \b       | 退格符         |
| \?       | 问号           |
| \f       | 进纸符         |
| \a       | 报警（响铃）符 |
| \\"      | 双引号         |
| \\'      | 单引号         |

使用\\x+16进制数字表示一个16进制数，使用\\+8进制数字表示一个8进制数，但8进制数最多匹配前三个数字。

字符和字符串字面值的**前缀**：

| 前缀 | 含义                          | 类型     |
| ---- | ----------------------------- | -------- |
| u    | Unicode 16 字符               | char16_t |
| U    | Unicode 32 字符               | char32_t |
| L    | 宽字符                        | wchar_t  |
| u8   | UTF-8（仅用于字符串字面常量） | char     |

## 2.2 变量

### 2.2.1 变量定义

初始化和赋值是不同的。

* 初始化的含义是创建变量时赋予其一个初始值。
* 赋值的含义是把对象的当前值擦除，以一个新值替代。

如果定义时没有指定初值，则变量被**默认初始化（default initialized）**。

* 定义在函数体之外的变量被初始化为0。
* 定义在函数体之内的变量不会被初始化，其值是不确定的。
* 定义在类内部的变量是否被初始化由类决定。如果类允许变量被默认初始化，则还可以决定对象的初始值是什么。

未被显式初始化的string对象是一个空字符串。

### 2.2.2 变量声明和定义的关系

为了支持分离式编译，C++将声明和定义区分开来。

* 声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。
* 定义（definition）负责创建与名字关联的实体。

声明不会申请存储空间，而定义会，而且可能会赋一个初值。变量只能被定义一次，但可以被多次声明。

如果要声明一个变量而不定义它，使用extern关键字：

`extern int i;		//声明i，不定义`

而`int i;`则会声明并定义。

通过extern声明的变量可以赋初值，但一旦赋值，变量就被自动定义，extern相当于白写了。在函数体内部初始化extern变量将引发错误。

### 2.2.3 标识符

用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。定义在函数体之外的标识符不能以下划线开头。

### 2.2.4 名字的作用域（scope）

名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。

在对象第一次被使用的地方附近定义它是一种好习惯。

作用域能彼此包含，被包含（或者说 被嵌套）的作用域称为**内层作用域（inner scope）**，包含着别的作用域的作用域被称为**外层作用域（outer scope）**。内层作用域可以访问外层作用域中的变量，也可以重新定义相同名字的变量来覆盖外层作用域的变量。在这种情况下，在变量名前面加`::`运算符可以访问**全局**变量：

```c++
    int unique = 0;
    ...
    {
        int unique = 1;
        std::cout << unique << std::endl;	//输出1
        std::cout << ::unique << std::endl;	//输出0
    }
```

如果函数有可能用到末全局变量，则最好不要再定义一个同名的局部变量。

## 2.3 复合类型（引用、指针）

复合类型（compound type）是指基于其他类型定义的类型。比如引用和指针。

引用是变量的别名。因为无法将已绑定的引用绑定在另一个新变量上，所以引用必须初始化。

引用本身不是对象，没有地址，因此不能定义引用的引用，也不能定义指向引用的指针。但指针是对象，因此可以定义对指针的引用：

```c++
int i = 42;
int *p;
int *&r = p;	//r是一个对指针p的引用

r = &i;			//给r赋值&i，就是令p指向i
*r = 0;			//将i的值改为0，等价于*p = 0;
```

要理解r到底是个什么东西，方法是**从右向左**阅读r的定义。离变量名最近的符号对变量的类型有最直接的影响。

`int &r2 = *p;`的意思是，将p指向的变量起一个叫r2的别名。

得到空指针的最直接的办法是使用字面值`nullptr`来初始化指针，而不要用C中的NULL。

建议尽可能初始化所有的指针。有对象就指向该对象，没有对象就赋个`nullptr`。

`void*`类型可以存放任意类型对象的地址，但不能直接使用。

## 2.4 const限定符

const对象一旦创建后其值就不能再改变，因此const对象必须初始化。

使用常量表达式初始化const变量时，编译器的行为与`#define`类似，即将当前文件所有的该变量名全部替换为常量表达式。

const对象只在当前文件有效。在不同文件定义同名const变量时，其实是定义了多个不同的变量。

想要让const对象在所有文件之间通用，需要使用extern关键字。

### 2.4.1 const的引用

可以把引用绑定在const对象上，称为**对常量的引用（reference to const）**。