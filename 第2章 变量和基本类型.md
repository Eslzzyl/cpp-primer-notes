## 2.1 基本内置类型

C++定义了一套包括**算术类型**（arithmetic type）和**空类型**（void）在内的数据类型。

### 2.1.1 算术类型

算术类型分两类：整型（integral type，包括字符型和bool型）和浮点型。

下表列出了C++标准规定的尺寸的最小值，允许编译器实现更大的尺寸。

| 类型        | 含义           | 最小尺寸     |
| ----------- | -------------- | ------------ |
| bool        | 布尔类型       | 未定义       |
| char        | 字符           | 8 bit        |
| wchar_t     | 宽字符         | 16 bit       |
| char16_t    | Unicode字符    | 16 bit       |
| char32_t    | Unicode字符    | 32 bit       |
| short       | 短整型         | 16 bit       |
| int         | 整型           | 16 bit       |
| long        | 长整型         | 32 bit       |
| long long   | 长整型         | 64 bit       |
| float       | 单精度浮点数   | 6位有效数字  |
| double      | 双精度浮点数   | 10位有效数字 |
| long double | 扩展精度浮点数 | 10位有效数字 |

C++规定，长度：short <= int <= long <= long long

long long是C++ 11新定义的。

除了bool型和字符型之外，整形可以分为**带符号的**（signed）和**无符号的**（unsigned）两种。

字符型有三种：char、signed char、unsigned char。实际表现出来的char只有后两种，第一种由编译器决定实现为后两者中的其中一种。

选用类型的经验准则：

* 明确知晓值不可能为负值时，使用无符号类型。
* 使用int执行整数运算，如果int太小，使用long long。
* 进行整数运算时不要用char或bool。因为char在有些机器上是有符号，在另一些机器上是无符号的。如果需要使用一个不大的整数，应当指明unsigned char或signed char。
* 进行浮点运算时使用double，而不用float。float的精度一般不够，而且float和double的运算成本相差无几。某些机器运算double甚至比float更快。long double一般不用。

类型转换（只记录了笔者不熟悉的规则）：

* 将bool转换为非bool类型时，bool为false则结果为0，bool为true则结果为1。
* 赋给无符号类型一个超出它表示范围的数时，结果为该数对该类型能表示的最大值取模。如unsigned char可以表示0~255，赋值>=256时，结果为该值对256取模。如果赋了一个负数，结果等于该类型表示的最大值减去该负数。
* 赋给带符号类型一个超出它表示范围的值时，结果是**未定义的**（undefined）。程序可能继续工作，可能崩溃，也可能生成垃圾数据。

### 2.1.3 字面值常量

C++的转义序列：

| 转义序列 | 含义           |
| -------- | -------------- |
| \n       | 换行符         |
| \v       | 纵向制表符     |
| \\       | 反斜线         |
| \r       | 回车符         |
| \t       | 横向制表符     |
| \b       | 退格符         |
| \?       | 问号           |
| \f       | 进纸符         |
| \a       | 报警（响铃）符 |
| \\"      | 双引号         |
| \\'      | 单引号         |

使用\\x+16进制数字表示一个16进制数，使用\\+8进制数字表示一个8进制数，但8进制数最多匹配前三个数字。

字符和字符串字面值的**前缀**：

| 前缀 | 含义                          | 类型     |
| ---- | ----------------------------- | -------- |
| u    | Unicode 16 字符               | char16_t |
| U    | Unicode 32 字符               | char32_t |
| L    | 宽字符                        | wchar_t  |
| u8   | UTF-8（仅用于字符串字面常量） | char     |

## 2.2 变量

### 2.2.1 变量定义

初始化和赋值是不同的。

* 初始化的含义是创建变量时赋予其一个初始值。
* 赋值的含义是把对象的当前值擦除，以一个新值替代。

如果定义时没有指定初值，则变量被**默认初始化（default initialized）**。

* 定义在函数体之外的变量被初始化为0。
* 定义在函数体之内的变量不会被初始化，其值是不确定的。
* 定义在类内部的变量是否被初始化由类决定。如果类允许变量被默认初始化，则还可以决定对象的初始值是什么。

未被显式初始化的string对象是一个空字符串。

### 2.2.2 变量声明和定义的关系

为了支持分离式编译，C++将声明和定义区分开来。

* 声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。
* 定义（definition）负责创建与名字关联的实体。

声明不会申请存储空间，而定义会，而且可能会赋一个初值。变量只能被定义一次，但可以被多次声明。

如果要声明一个变量而不定义它，使用extern关键字：

`extern int i;		//声明i，不定义`

而`int i;`则会声明并定义。

通过extern声明的变量可以赋初值，但一旦赋值，变量就被自动定义，extern相当于白写了。在函数体内部初始化extern变量将引发错误。

### 2.2.3 标识符

用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。定义在函数体之外的标识符不能以下划线开头。

### 2.2.4 名字的作用域（scope）

名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。

在对象第一次被使用的地方附近定义它是一种好习惯。

作用域能彼此包含，被包含（或者说 被嵌套）的作用域称为**内层作用域（inner scope）**，包含着别的作用域的作用域被称为**外层作用域（outer scope）**。内层作用域可以访问外层作用域中的变量，也可以重新定义相同名字的变量来覆盖外层作用域的变量。在这种情况下，在变量名前面加`::`运算符可以访问**全局**变量：

```c++
    int unique = 0;
    ...
    {
        int unique = 1;
        std::cout << unique << std::endl;	//输出1
        std::cout << ::unique << std::endl;	//输出0
    }
```

如果函数有可能用到末全局变量，则最好不要再定义一个同名的局部变量。

## 2.3 复合类型（引用、指针）

复合类型（compound type）是指基于其他类型定义的类型。比如引用和指针。

引用是变量的别名。因为无法将已绑定的引用绑定在另一个新变量上，所以引用必须初始化。

引用本身不是对象，没有地址，因此不能定义引用的引用，也不能定义指向引用的指针。但指针是对象，因此可以定义对指针的引用：

```c++
int i = 42;
int *p;
int *&r = p;	//r是一个对指针p的引用

r = &i;			//给r赋值&i，就是令p指向i
*r = 0;			//将i的值改为0，等价于*p = 0;
```

要理解r到底是个什么东西，方法是**从右向左**阅读r的定义。离变量名最近的符号对变量的类型有最直接的影响。

`int &r2 = *p;`的意思是，将p指向的变量起一个叫r2的别名。

得到空指针的最直接的办法是使用字面值`nullptr`来初始化指针，而不要用C中的NULL。

建议尽可能初始化所有的指针。有对象就指向该对象，没有对象就赋个`nullptr`。

`void*`类型可以存放任意类型对象的地址，但不能直接使用。

## 2.4 const限定符

const对象一旦创建后其值就不能再改变，因此const对象必须初始化。

使用常量表达式初始化const变量时，编译器的行为与`#define`类似，即将当前文件所有的该变量名全部替换为常量表达式。

const对象只在当前文件有效。在不同文件定义同名const变量时，其实是定义了多个不同的变量。

想要让const对象在所有文件之间通用，需要使用extern关键字。

### 2.4.1 const的引用

可以把引用绑定在const对象上，称为**对常量的引用（reference to const）**，往往被简称为“常量引用”。这时引用本身也必须是const的。

```c++
double dval = 3.14;
const int &ri = dval;
```

上面这两条语句会被编译器自动扩展为

```c++
double dval = 3.14;
const int temp = dval;
const int &ri = dval;
```

这里的temp被称为**临时量（temporary）**对象。ri必须是const的，因为ri绑定的是临时量，不能改变，因此ri非const时编译器将报错。

允许将const引用绑定在非const对象上，但此时无法通过该引用改变对象的值。通过其他方式仍然可以改变对象的值。

### 2.4.2 指针和const

指向常量的指针性质与上面的引用类似，指向const对象的指针本身也必须是const的；不能通过这种指针修改对象的值，即使对象是非const的。

`int *const p`表示p本身是一个const型的指针，即指向的对象是固定的，不能指向其他对象。其指向的对象应为非const的int，**可以**通过该指针修改int变量的值。

`const int *const p`表示p本身是一个const型的指针，且指向的对象应当是const int或非const int。**不能**通过该指针修改对象的值。

### 2.4.3 顶层const

从上节可以看出，指针本身是不是常量 以及 指针所指的是不是一个常量 是两个相互独立的问题。

名词**顶层const**（top-level const）表示当前声明对象是常量。

名词**底层const**（low-level const）只用来描述复合类型，表示当前声明的指针所指的对象是一个常量，或引用绑定的对象是一个常量。用于声明引用的const**一定**是底层const。

例子：

```c++
int i = 0;
int *const p1 = &i;		//顶层const
const int ci = 42;		//顶层const
const int *p2 = &ci;	//底层const
const int *const p3 = p2;	//靠右的const是顶层const，靠左的是底层const
const int &r = ci;		//用于声明引用的const都是底层const
```

在执行对象的拷贝操作时，顶层const不受影响，拷入/拷出的对象都可以是const或非const。底层const则有限制。拷入和拷出的对象必须具有相同的底层const资格，或者两个对象是数据类型必须能够转换。一般来说，非常量可以转换为常量，反之则不行：

```c++
int *p = p3;		//错误：p3包含底层const的定义，而p没有
p2 = p3;			//正确：p2和p3都是底层const
p2 = &i;			//正确：int*可以转换为const int*
int &r = ci;		//错误：普通的int&不能绑定到int常量上
const int &r2 = i;	//正确：const int&可以绑定到一个普通int上
```

### 2.4.4 constexpr和常量表达式

**常量表达式**（const expression）是指值不会改变**并且**在编译过程就能得到计算结果的表达式。

C++ 11规定，允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式。声明为`constexpr`的变量一定是一个常量（顶层const），而且必须用常量表达式初始化，在编译时就得到计算：

```c++
constexpr int mf = 20;			//20是常量表达式
constexpr int limit = mf + 1;	//mf + 1是常量表达式
constexpr int sz = size();		//只有当size()是一个constexpr函数时才是正确的
```

## 2.5 处理类型

### 2.5.1 类型别名

除了继承自C的typedef之外，C++ 11允许使用using来规定类型别名：

`using SI = Sales_item;`则`SI`是`Sales_item`的别名。

注意，`typedef char *pstring;`中pstring是char *的别名。

### 2.5.2 auto类型说明符

C++ 11允许使用auto关键字定义变量，让编译器自动推断表达式所属的类型。auto定义的变量必须有初始值，auto语句如定义了多个变量，这些变量的数据类型必须一致，因为一条声明语句只能有一个基本数据类型。

一些特殊情况：

* 使用引用作为auto的初始值时，编译器选择的类型实际上是被引用对象的类型。
* auto一般会忽略顶层const，保留底层const。

```c++
const int ci = i; &cr = ci;		//ci是顶层const，cr是底层const
auto b = ci;	//b是整型，ci的const性质被忽略
auto c = cr;	//c同b，cr是一个顶层const(ci)的引用
auto e = &ci;	//e是一个指向整数常量的指针
```

如果希望推断出的auto类型是一个顶层const，需要明确指出：

```c++
const auto f = ci;	//ci的推断类型是int（const被忽略），f是const int
auto &h = 42;		//错误：不能为非常量引用绑定字面值
const auto &j = 42;	//正确
```

### 2.5.3 decltype类型指示符

有时我们希望使用表达式的类型，但又不想用这个表达式为新变量赋值，此时可以使用`decltype`：返回操作数的数据类型。如果操作数是一个表达式，则`decltype`返回表达式结果对应的类型。

对变量使用`decltype`时，会保留顶层const和引用（如果有）。引用从来都是作为被引用对象的同义词出现，只有在此处是一个例外。

```c++
decltype(f()) sum = x;	//sum是fun()返回值的类型
const int ci = 0, &cj = ci;
decltype(ci) x = 0;		//x是const int
decltype(cj) y = x;		//y是const int&，绑定到x。y是一个引用，必须初始化。
//如果想要让y是cj所绑定的对象的类型，可以用：
decltype(cj + 0) y;
```

如果给变量加了括号，则其成为一个表达式。

```c++
decltype((i)) d;	//错误：d是int&，必须绑定一个int变量
decltype(i) e;		//正确：e是一个（未初始化的）int
```

`decltype((var))`的结果永远是引用，而`decltype (var)`的结果要看var的类型，只有当var是引用时，结果才是引用。

## 2.6 自定义数据结构

### 2.6.3 编写自己的头文件

类通常在头文件中定义，且头文件的名字应该和类名保持一致。如`string`类在`头文件string`中定义，`Sales_data`类也应该在`Sales_data.h`中定义。

头文件通常包含那些只能被定义一次的实体，如类、`const`和`constexpr`变量等。头文件一旦改动，包含它的源文件也要重新编译来获取新的声明。

所有头文件都最好加放重入，即使头文件很简单。