## 12.1 动态内存与智能指针

C++ 11提供了两种**智能指针（smart pointer）**类型来管理动态对象。智能指针可以自动释放所指向的对象。

- `shared_ptr`允许多个指针指向同一个对象；
- `unique_ptr`“独占”所指向的对象。

标准库还定义了一个名为`weak_ptr`的伴随类，它是一种弱引用，指向`shared_ptr`所管理的对象。

以上三种类型均定义在头文件`memory`中。

标准库的较早版本包含了一个名为`auto_ptr`的类，它具有`unique_ptr`的部分特性，功能受限较多。目前`auto_ptr`仍然在标准库中，但不宜使用。

### 12.1.1 `shared_ptr`类

智能指针也是模板。因此创建智能指针时必须使用尖括号指明指针指向的类型。

```c++
shared_ptr<string> p1;
shared_ptr<list<int>> p2;
```

默认初始化的智能指针中保存着一个空指针。

下表列出了`shared_ptr`和`unique_ptr`都支持的操作：

| 操作                                   | 描述                                                  |
| -------------------------------------- | ----------------------------------------------------- |
| `shared_ptr<T> sp`与`unique_ptr<T> sp` | 空智能指针，可以指向类型为`T`的对象                   |
| `p`                                    | 将`p`作为一个条件判断，若`p`指向一个对象，则为`true`  |
| `*p`                                   | 解引用`p`，获得它所指向的对象                         |
| `p->mem`                               | 等价于`(*p).mem`                                      |
| `p.get()`                              | 返回`p`中保存的指针。通过此方法获得的指针无法`delete` |
| `swap(p, q)`或`p.swap(q)`              | 交换`p`和`q`中的指针，推荐使用第一种                  |

`p.get()`要小心使用。若智能指针释放了其对象，返回的指针所指向的对象也就消失了。

下表列出了`shared_ptr`独有的操作。

| 操作                   | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `make_shared<T>(args)` | 返回一个`shared_ptr`，指向一个动态分配的类型为`T`的对象。使用`args`初始化此对象 |
| `shared_ptr<T>p(q)`    | `p`是`shred_ptr`对象`q`的拷贝，此操作会递增`q`中的计数器。`q`中的指针必须能转换为`T*` |
| `p == q`               | `p`和`q`都是`shared_ptr`，所保存的指针必须能相互转换。此操作会递减`p`的引用计数，递增`q`的引用计数；若`p`的引用计数减为`0`，则将其管理的原内存释放 |
| `p.unique()`           | 若`p.use_count()`为`1`，返回`true`，否则返回`false`          |
| `p.use_count()`        | 返回与`p`共享对象的智能指针数量；可能很慢，主要用于调试      |

#### `make_shared`函数

最安全的分配和使用动态内存的方法是调用一个名为`make_shared`的标准库函数。该函数同样定义于`memory`头文件。

调用该函数时，同样需要使用尖括号`<>`指明类型。它用小括号`()`内的参数来初始化指定的类型的对象。

#### `shared_ptr`的拷贝和赋值

进行拷贝或赋值操作时，每个`sharede_ptr`都会记录有多少个其他`shared_ptr`指向相同的对象。每个`shared_ptr`都有一个关联的计数器（实现细节由编译器决定），称为**引用计数(reference count)**。

- 每拷贝一次`shared_ptr`，计数器都会递增。
- 每当为`shared_ptr`赋予一个新值或是`shared_ptr`被销毁（如离开作用域）时，计数器将递减。
- 一旦一个`shared_ptr`的计数器变为0，它就自动释放自己所管理的对象。

只有当最后一个`shared_ptr`被销毁或是和对象解除绑定后，对象才被释放，所以最后一个`shared_ptr`不再使用后，要记得销毁该`shared_ptr`，否则对象始终不会被释放。一个例子是，将`shared_ptr`放进某种容器，随后使用重排算法重排这个容器，有时会产生不再使用的单元（典型例子：`unique()`），此时宜使用`erase()`抹掉不用的单元。

#### 使用了动态内存期的资源的类

程序使用动态内存出于以下三种原因之一：

1. 程序不知道自己需要使用多少对象（典例：容器类）
2. 程序不知道所需对象的准确类型（典例：模板类）
3. 程序需要再多个对象间共享数据（典例：使用智能指针的类）

### 12.1.2 直接管理内存

C++定义了`new`和`delete`运算符，用于手动管理内存。

#### 使用`new`动态分配和初始化对象

`new`返回一个指向其分配的对象的指针：

```c++
int *pi = new int;
```

`new`分配的对象执行默认初始化(2.2.1节)。

我们可以在使用`new`时直接初始化：

```c++
int *pi = new int(2014);
vector<int> *pv = new vector<int>{0, 1, 2, 3, 4, 5}; //C++ 11
```

如果跟了空的小括号`()`，则执行的是值初始化(3.3.1节)。推荐使用这种方式取代默认的初始化。

如果使用了小括号（花括号）指定初始化列表，则可以使用`auto`自动推导类型，但`auto`只能用于**单一初始化器**的初始化：

```c++
auto p1 = new auto(obj);		//使用推导的obj类型初始化p1
auto p2 = new auto(a, b, c);	//错误：多初始化器
```

#### 动态分配的`const`对象

允许使用`new`分配`const`对象：

```c++
const int *pc1 = new const int(1024);
```

#### 内存耗尽

如果`new`分配内存失败，则它抛出一个`bad_alloc`异常。我们可以使用`nothrow`来改变这一行为。

```c++
int *p1 = new (nothrow) int;
```

这种情况下，如果`new`分配内存失败，将返回一个`nullptr`。这种`new`称为**定位new(replacement new)**

`bad_alloc`和`nothrow`都定义在头文件`new`中。

#### 指针值和`delete`

用`delete`释放一块并非由`new`分配的内存，或是将同一块内存`delete`多次，其结果是未定义的。

使用`new`分配的`const`对象不能改变值，但是仍然可以通过`delete`销毁。

使用`new`和`delete`管理动态内存容易犯的三个错误：

1. 忘记`delete`内存。
2. 使用已经释放的对象。
3. 将同一块内存释放多次。

在很多机器上，使用`delete`释放内存后，指针不会被销毁，而且其中仍然保存着之前的内存的地址，这就是所谓的**空悬指针(dangling pointer)**。

为了避免出现空悬指针，有两种方案：

1. 在指针即将离开其所在的作用域之前对其使用`delete`。
2. 如果指针之后还要使用，就在`delete`之后赋予其一个`nullptr`。

### 12.1.3 `shared_ptr`和`new`结合使用

我们可以使用`new`返回的指针来初始化`shared_ptr`。接受指针参数的智能指针构造函数是`explicit`的，所以只能使用直接初始化：

```c++
shared_ptr<int> p1(new int(42));	//正确
shared_ptr<int> p2 = new int(1024);	//错误，依赖隐式转换
```

| 操作                     | 描述                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `shared_ptr<T> p(q)`     | `p`管理内置指针`q`所指向的对象；`q`必须指向`new`分配的内存，且能转换为`T*`类型 |
| `shared_ptr<T> p(u)`     | `p`从`unique_ptr u`那里接管了对象的所有权；将`u`置为空       |
| `shared_ptr<T> p(q, d)`  | `p`接管了内置指针`q`所指向的对象的所有权。`q`必须能转换为`T*`类型。`p`将使用可调用对象`d`来代替`delete`（一般称`d`为“删除器”） |
| `shared_ptr<T> p(p2, d)` | `p`是`shared_ptr p2`的拷贝，`p`将用可调用对象`d`来代替`delete` |
| `p.reset()`              | 若`p`是唯一指向其对象的`shared_ptr`，`reset`会释放此对象。下同。无参数时将`p`置为`nullptr` |
| `p.reset(q)`             | 令`p`指向`q`                                                 |
| `p.reset(q, d)`          | 同上，此外使用可调用对象`d`代替`delete`                      |

使用内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法知道对象何时会被销毁。

永远不要使用`get()`返回的内置指针来初始化一个智能指针。

### 12.1.4 智能指针和异常

如果在`new`和`delete`之间发生了异常，且捕获异常时未使用`delete`，则会发生内存泄漏。使用智能指针不会出现这样的问题。

### 12.1.5 `unique_ptr`

某个时刻只能有一个`unique_ptr`指向一个给定对象。当`unique_ptr`被销毁时，它指向的对象也被销毁。

没有类似`make_shared()`的函数返回一个`unique_ptr`，所以要定义一个`unique_ptr`，需要将其绑定到一个`new`返回的指针上（使用直接初始化）。

```c++
unique_ptr<double> p1;
unique_ptr<int> p2(new int(42));
```

`unique_ptr`独占对象，因此它不支持拷贝与赋值。

下表列出了`unique_ptr`独有的操作。

| 操作                    | 描述                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `unique_ptr<T> u1`      | 空`unique_ptr`，可以指向类型为`T`的对象。`u1`将使用`delete`来释放它的指针 |
| `unique_ptr<T, D> u2`   | `u2`会使用一个类型为`D`的可调用对象来释放它的指针            |
| `unique_ptr<T, D> u(d)` | 空`unique_ptr`，指向类型为`T`的对象，用类型为`D`的对象`d`来代替`delete` |
| `u = nullptr`           | 释放`u`指向的对象，将`u`置为空                               |
| `u.release()`           | `u`放弃对指针的控制权，返回指针，将`u`置为空                 |
| `u.reset()`             | 释放`u`指向的对象，下同                                      |
| `u.reset(q)`            | 使`u`指向`q`                                                 |
| `u.reset(nullptr)`      | 将`u`置空                                                    |

如果我们不使用另一个智能指针接受`release()`的返回值，则内存将被释放。

#### 传递`unique_ptr`参数和返回`unique_ptr`

不能拷贝`unique_ptr`的规则有一个例外：我们可以拷贝或赋值以后个即将被销毁的`unique_ptr`。

```c++
unique_ptr<int> clone(int p) {
    return inque_ptr<int>(new int(p));
}

//或者

unique_ptr<int> clone(int p) {
   	unique_ptr<int> ret(new int(p));
    return ret;
}
```

有关这类拷贝，可参见13.6.2节。

### 12.1.6 `weak_ptr`

`weak_ptr`指向一个`shared_ptr`指向的对象，它不控制对象生存期。`weak_ptr`不改变引用计数，而且不能阻止对象在最后一个`shared_ptr`解绑后被释放。

| 操作                | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| `weak_ptr<T> w`     | 空`weak_ptr`，可以指向类型为`T`的对象                        |
| `weak_ptr<T> w(sp)` | 与`shared_ptr sp`指向相同对象的`weak_ptr`。`T`必须能转换为`sp`指向的类型 |
| `w = p`             | `p`可以是一个`shared_ptr`或一个`weak_ptr`。赋值后`w`与`p`共享对象 |
| `w.reset()`         | 将`w`置为空                                                  |
| `w.use_count()`     | 与`w`共享对象的`shared_ptr`的数量                            |
| `w.expired()`       | 若`w.use_count()`为`0`，返回`true`，否则返回`false`          |
| `w.lock()`          | 如果`expired`为`true`，返回一个空`shared_ptr`；否则返回一个指向`w`的对象的`shared_ptr` |

创建`weak_ptr`时，要用一个`shared_ptr`来初始化它：

```c++
auto p = make_shared<int>(42);
weak_ptr<int> wp(p);
```

由于对象可能不存在，我们不能用`weak_ptr`直接访问对象，而应该使用`lock()`。

## 12.2 动态数组

`new`/`delete`一次分配/释放一个对象。有时我们需要分配连续的多个对象，就像数组那样。C++提供了两种一次分配一个对象数组的方法。

- C++定义了另一种`new`表达式语法，用于分配和初始化对象数组。
- 标准库中包含一个`allocator`类，实现类似的功能。

使用`allocator`通常会提供更好的性能和更灵活的内存管理能力。

大多数程序应该使用标准库容器而不是动态分配的数组。

### 12.2.1 `new`和数组

为了让`new`分配对象数组，需要在类型名后跟一个方括号，指明要分配的对象的数目，这个数目必须是整型，但不必是常量。`new`会返回指向该对象数组的**第一个**对象的指针。

```c++
int *pia = new int[get_size()];
```

也可以用一个表示数组类型的类型别名来分配数组，这样在`new`表达式中就不需要方括号了。

```c++
typedef int arrT[42];	//arrT表示42个int的数组类型
int *p = new arrT;

//编译器实际执行的语句：
int *p = new int[42];
```

`new`分配的对象执行默认初始化。要想执行值初始化，需要跟一对空小括号。C++ 11也支持使用花括号。

```c++
string *psa3 = new string[10]{"a", "an", "the", string(3, 'x')};
```

如果初始化器数目小于元素数目，剩余元素执行值初始化。如果初始化器数目大于元素数目，则`new`抛出`bad_array_new_length`异常。

不能在小括号中给出初始化器，这也意味着不能使用`auto`分配数组。

#### 动态分配一个空数组是合法的

允许出现类似

```c++
char *cp = new char[0];
```

的写法，`new`将返回一个合法的非空指针，这就好像尾后迭代器一样。可以将该指针加上或减去0得到它本身，或者减去它本身得到0，但该指针**不能解引用**。

#### 释放动态数组

释放动态数组要求一种特殊的`delete`写法——在指针前加上一个空的方括号对：

```c++
delete[] pa;
```

数组中的元素将按照**逆序**销毁。如果销毁动态数组时没有带方括号`[]`，则结果是未定义的。

#### 智能指针和动态数组

有一类`unique_ptr`专门用于管理`new`分配的数组。我们需要在对象类型后加一对方括号：

```c++
unique_ptr<int[]> ip(new int[10]);
up.release();	//自动使用delete[]销毁
```

`int[]`表示`up`指向一个数组。可以使用下标运算符访问数组的成员：`up[3]`。

`shared_ptr`不直接支持管理动态数组。为了使用`shared_ptr`，需要提供自己定义的删除器。

```c++
shared_ptr<int> sp(new int[10], [](int *p){ delete[] p; });
sp.reset();	//使用我们提供的lambda释放数组
```

`shared_Ptr`没有定义下标运算符，因此不可使用。

### 12.2.2 `allocator`类

`allocator`类定义在头文件`memory`中，它可以将内存分配和对象构造分离开来。它分配的内存是原始的、未构造的。

`allocator`同样是模板，因此需要尖括号。使用`allocator`时，它会自动确定恰当的内存大小和对齐位置。

```c++
allocator<string> alloc;
auto const p = alloc.allocate(n);	//分配n个未初始化的string
```

| 操作                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| `allocator<T> a`      | 定义了一个名为`a`的`allocator`对象，它可以为类型`T`的对象分配内存 |
| `a.allocate(n)`       | 分配一段原始的、未构造的内存，保存`n`个类型为`T`的对象       |
| `a.deallocate(p, n)`  | 释放从`T*`指针`p`中地址开始的内存，这块内存保存了`n`个类型为`T`的对象；`p`必须是一个先前由`allocate`返回的指针，`n`必须是`p`创建时所要求的大小。调用本函数前，必须先对要释放的内存中的每个创建的对象调用`destroy` |
| `a.construct(p, arg)` | `p`必须是一个类型为`T*`的指针，指向一块原始内存；`arg`被传递给类型为`T`的构造函数，用来在`p`指向的内存中构造一个对象 |
| `a.destroy(p)`        | `p`为`T*`类型的指针，此算法对`p`指向的对象执行析构函数       |

#### `allocator`分配未构造的内存

要使用`allocate`分配的内存，必须先使用`construct`构造对象。使用未构造的内存，结果是未定义的。

对先前的`string`的例子，有：

```c++
auto q = p;
alloc.construct(q++);	//*q为空字符串
alloc.construct(q++, 10, 'c');	//*q为cccccccccc
alloc.construct(q++, "hi");	//*q为hi
```

用完对象后，必须对**每个**构造的对象调用`destroy`。调用之后，可以再次使用，也可以释放内存。

```c++
while (q != p)
    alloc.destroy(--q);
```

只能对真正构造了的元素使用`destroy`。

释放内存则通过调用`deallocate`来完成。

#### 拷贝和填充未初始化内存的算法

头文件`memory`中还定义了两个函数，可以在未初始化内存中创建对象。

| 操作                           | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| `uninitialized_copy(b, e, b2)` | 从迭代器`b`和`e`指出的输入范围中拷贝元素到迭代器`b2`指定的未构造的原始内存中。`b2`指向的内存必须足够大 |
| `uninitialized_copy(b, n, b2)` | 从迭代器`b`指向的元素开始，拷贝`n`个元素到`b2`开始的内存中   |
| `uninitialized_fill(b, e, t)`  | 在迭代器`b`和`e`指定的原始内存范围中创建对象，对象的值均为`t`的拷贝 |
| `uninitialized_fill(b, n, t)`  | 从迭代器`b`指向的内存地址开始创建`n`个对象。`b`指向的内存空间必须足够大 |

## 12.3 使用标准库：文本查询程序

[内容待补]