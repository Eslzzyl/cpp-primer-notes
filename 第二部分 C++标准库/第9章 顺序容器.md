**顺序容器（sequential container）**为程序员提供了控制元素存储和访问顺序的能力。这些元素的顺序取决于元素加入容器的顺序，而不是元素的值。

## 9.1 顺序容器概述

| 容器名         | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| `vector`       | 可变大小数组，支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。 |
| `deque`        | 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快      |
| `list`         | 双向链表。只支持双向顺序访问。在任何位置插入/删除都很快。内存开销较大 |
| `forward_list` | 单向链表。只支持单向顺序访问。在任何位置插入/删除都很快。速度不慢于最快的手写单向链表。内存开销较大（C++ 11） |
| `array`        | 与`vector`的唯一不同点是大小固定，C++ 11引入，用于完全取代传统数组 |
| `string`       | 与`vector`类似，仅能用于保存字符                             |

总的来说，使用顺序容器时，`vector`是首选的。

如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问，那么：

- 首先确定是否真的需要在中间位置插入元素。可以使用`vector/deque`在尾（头）部插入，输入完毕后使用`std::sort()`。
- 如果确实需要在中间位置插入元素，考虑在输入阶段使用`list`，一旦输入完成，将`list`的内容拷贝到一个`vector`。

## 9.2 容器库概览

本节介绍对所有标准库容器都适用的操作。本章剩余部分介绍顺序容器特有的操作。

所有标准库容器都有以下的类型：

| 类型              | 描述                                                   |
| ----------------- | ------------------------------------------------------ |
| `iterator`        | 此容器类型的迭代器类型                                 |
| `const_iterator`  | 只读的迭代器类型                                       |
| `size_type`       | 无符号整数类型，足够保存此种容器类型最大可能容器的大小 |
| `difference_type` | 带符号整数类型，足够保存两个迭代器之间的距离           |
| `value_type`      | 元素类型                                               |
| `reference`       | 元素的左值类型；与`value_type&`含义相同                |
| `const_reference` | `reference`的`const`版本，即`const value_type&`        |

只有顺序容器的构造函数才接受大小参数，关联容器不支持。

`array`的大小也是类型的一部分（这与内置数组一样）。定义一个`array`时，要同时指定元素类型和大小：

```c++
array<int, 42>
array<string, 10>
```

使用时也是一样：

```c++
array<int, 10>::size_type i;
```

一个默认构造的`array`含有和其大小一样多的元素，元素被默认初始化（2.2.1节）。

内置数组不支持拷贝或**对象**赋值，但是`array`支持。不过`array`仍然不支持花括号形式的列表赋值，因为列表中值的类型和个数不一定能满足要求。

### 9.2.5 赋值和`swap`

| 赋值运算                        | 描述                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| `c1 = c2`                       | 将`c1`中的元素替换为`c2`中元素的拷贝。`c1`和`c2`的类型必须相同 |
| `c = {a, b, ,c, ...}`           | 将`c1`中元素替换为初始化列表中元素的拷贝（`array`不适用）    |
| `swap(c1, c2);`或`c1.swap(c2);` | 交换`c1`和`c2`中的元素。`c1`和`c2`必须具有相同的类型。`swap`通常比拷贝快得多。建议使用第一种写法 |
| `seq.assign(b, e)`              | 将`seq`中的元素替换为迭代器`b`和`e`所表示的范围中的元素。`b`和`e`不能指向`seq`中的元素 |
| `seq.assign(il)`                | 将`seq`中的元素替换为初始化列表`il`中的元素                  |
| `seq.assign(n, t)`              | 将`seq`中的元素替换为`n`个值为`t`的元素                      |

**注**：

- `assign`不能用于关联容器和`array`。
- 赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。
- `swap`操作容器**不会**导致上述组件失效（`array`和`string`除外）

`swap`不对任何元素进行拷贝、删除和插入操作，因此是`O(1)`的。但`array`除外，`swap`将逐个交换元素。

### 9.2.7 关系运算符

每个容器类型都支持`==`和`!=`。除了无序关联容器外的所有容器都支持`>`、`<`、`>=`和`<=`。比较仅限于相同类型的容器。

容器的比较是基于对元素的`==`和`<`比较实现的。因此若想要包含自定义类型的容器支持比较，需要定义`==`和`<`运算。

比较的行为如下：

- 若容器大小相等且所有元素都对应相等，则两容器相等。
- 若容器大小不等，但较小容器中每个元素都**等于**较大容器中的对应元素，则较小容器**小于**较大容器。
- 若两容器都不是另一个容器的前缀子序列，则比较结果取决于**第一个**不相等的元素的比较结果。

## 9.3 顺序容器操作

由于单向链表实现特殊，`forward_list`不支持通用的`insert`、`erase`和`emplace`操作。它有一套独有的`insert_after()`、`emplace_after()`和`erase_after()`操作，相比通用操作，其操作对象都向后移动了一个位置。以下程序删除一个`forward_list`中的奇数元素。

```c++
forward_list<int> flst = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
auto prev = flst.before_begin();	//表示flst的“首前元素”
auto curr = flst.begin();		//表示flst的第一个元素
while (curr != flst.end()) {
    if (curr % 2)
        curr = flst.erase_after(prev);
    else {
        prev = curr;
        ++curr;
    }
}
```

## 9.4 `vector`对象是如何增长的

在不得不获取新的内存空间时，`vector`和`string`的实现通常会分配比新的需求空间更大的内存空间（具体大小取决于标准库实现），并将数据全部拷贝过去。这样的设计保证`vector`可以高性能增长，扩张操作甚至比`list`和`deque`还要快。

| 大小管理操作        | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| `c.shrink_to_fit()` | 只适用于`vector`、`string`和`deque`。该操作**请求**将`capacity()`减小为与`size()`相同的大小，不能保证一定成功 |
| `c.capacity()`      | 在不重新分配内存空间的前提下，`c`可以保存的元素个数          |
| `c.reserve(n)`      | 分配至少能容纳`n`个元素的内存空间                            |

注意将`capacity`与`size`区分。`size`是指容器已经保存的元素数目。

## 9.5 额外的`string`操作

原书非常详尽地讲解了`string`类的各类用法，此处略去。

## 9.6 容器适配器

**适配器（adapter）**是标准库的一个通用概念。容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为看起来像是另一种事物一样。

标准库定义了三个顺序容器适配器：`stack`、`queue`和`priority_queue`。`stack`和`queue`默认是基于`deque`实现的，`priority_queue`默认是基于`vector`实现的。

假定`deq`是一个`deque<int>`，下面的代码用`deq`初始化了一个`stack<int>`：

```c++
stack<int> stk(deq);
```

可以在创建适配器时指定默认的顺序容器。`stack`可以使用除`array`和`forward_list`外的任何标准库顺序容器：

```c++
//str_stk2在vector上实现，初始化时保存svec的拷贝
stack<string, vector<string>> str_stk(svec);
```

